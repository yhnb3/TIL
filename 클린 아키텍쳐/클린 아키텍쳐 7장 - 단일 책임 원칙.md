## 7장 단일책임원칙

단일책임원칙은 많은 이들에게 제대로 전달되지 않는 경우가 많다. 프로그래머들이 이 원칙의 이름을 들으면 아마 하나의 모듈은 하나의 일을 해야함을 떠올릴 것이다. 하지만 이는 하나의 함수는 하나의 일을 해야한다는 원칙에 해당되는 것이다. 그럼 단일책임원칙의 진짜 목적은 무엇일까?

> 바로 단일 모듈은 변경의 이유가 오직 하나뿐이어야한다.

그럼 변경의 이유는 어디에서 오는가? 사용자 혹은 이해관계자들에게서 올 것 이다. 그럼 우리는 어떠한 모듈의 변경을 원하는 사람들의 집단을 `액터`라고 칭한다면 단일 책임 원칙은 또 다음과 같이 표현할 수 있습니다.

> 하나의 모듈은 하나의 , 오직 하나의 액터에 대해서만 책임져야한다.

아마 다들 이런식으로만 들으면 원칙을 어떻게 지켜야 할지에 대해 감이 잘 오지 않을 것이다. 그럼 이 원칙을 위반하면 생기는 징후를 통해 어떤 식으로 원칙을 지킬수 있는지에 대해 알아보자.

#### 징후 1 . 우발적 중복

`Employee`라는 클래스에 `calculatePay`, `reportHours`, `save`란 메서드가 존재 한다. 하지만 이 3가지의 메서드는 액터들이 모두 다른 메서드이다. 이러한 결합들로 인해 어떤 한 액터가 만든 변화가 다른 액터가 핸들링하는 모듈에 영향을 끼칠 수 있게 된 것이다.

그리고 `reportHours`와 `calculatePay`에서 사용할 수 있는 공통 함수인 `regularHours`를 만들었다고 생각해보자. `calculatePay`를 만드는 사용자는 `regularHours`가 `calculatePay`이 외의 곳에서 사용되는 것은 인지 하지 못한채 `regularHours`에 대한 변경 요청 사항을 적용하고 신중하게 테스트를 했습니다. 하지만 이는 `reportHours`에 어떤 문제를 가져오게 될지 예측할 수 없습니다. 그래서 **서로 다른 액터가 의존하게 되는 코드는 무조건 분리해야합니다.**

#### 징후 2. 병합

서로 다른 액터가 하나의 소스파일을 변경하게 되면 어떻게 될까? 그러면서 각자의 변경사항을 하나의 소스파일에 적용하려고 했을때 어떤 문제가 생길 것인가? 다들 알다시피 병합에 대한 에러가 발생할 것입니다. 충돌이 발생하고 그 충돌을 해결하기 위해 또 많은 리소스들을 소비해야합니다. 

이러한 문제는 어떤 식으로 해결할 수 있을까요?

가장 일반적인 방법은 `facade`패턴이 있다. 메서드와 데이터 클래스를 분리하는 방식이다. 아무런 메서드가 없는 Data 클래스를 만들어 세 개의 클래스가 공유하도록합니다. 각 클래스는 자신의 메서드에 대한 소스만 포함해야 합니다. 이런식으로 코드를 짠다면 Data 클래스에 사용되는 각 메서드에 관한 클래스를 추적하기가 어려워 질 수 있다. 그래서 사용되는 것이 `facade` 패턴이고 이는 `facade` 클래스를 하나 만들어서 이 클래스에 메서드 객체를 생성하고 요청된 메서드를 가지는 객체로 위임하는 일을 하게 합니다. 



