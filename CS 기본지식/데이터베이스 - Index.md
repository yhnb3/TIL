# Index

### 인덱스란?

인덱스는 말그대로 색인이다. 데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호가 될 것이다. DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다.

DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다. 결론적으로 DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.

### Index 자료구조

그렇다면 DBMS는 인덱스를 어떻게 관리하고 있는가

**B+-Tree 인덱스 알고리즘**

일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다. B+-Tree 인덱스는 칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리한다.), 원래의 값을 이용해 인덱싱하는 알고리즘이다.

**Hash 인덱스 알고리즘**

칼럼의 값으로 해쉬 값을 계산해서 인덱시하는 알고리즘으로 매우 빤른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

**왜 index를 생성하는데 b-tree를 사용하는가?**

데이터에 접근하는 시간복잡도가 O(1)인  hash table이 더 효율적인거 같다. 하지만 SELECT 질의의 조건에는 부등호 연산도 포함이 된다. hash table을 사용하게 된다면 등호 연산이 아닌 부등호 연산의 경우에 문제가 발생한다. 동등 연산에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지않다.

**Primary Index vs Secondary Index**

클러스터란 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, 클러스터도 인덱스도 크게 다르지 않다. 인덱스에서 클러스터는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안된 것이다. 여기서 비슷한 값들을 물리적으로 인접한 장소에 저장되어 있는 데이터들을 말한다.

클러스터드 인덱스는 데이블의 프라이머리 키에 대해서만 적용되는 내용이다. 즉 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라고 표현한다. 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야한다. 그렇기 때문에 프라이머리 키를 신중하게 결정하고 크러스터드 인덱스를 사용해야한다.

클러스터드 인덱스는 테이블 당 한개만 생성할 수 있다. 프라이머리 키에 대해서만 적용되기 때문이다. 이에 반해 non클러스터드 인덱스는 테이블당 여러 개를 생성할 수 있다.

**Composite Index**

인덱스로 설정하는 필드의 속성이 중요하다. title, author 이 순서로 인덱스를 설정한다면 title을 search하는 경우, index를 생성한 효과를 볼수 있지만, author만으로 search하는 경우, index를 생성한 것이 소용이 없어진다. 따라서 SELECT 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.

### Index의 성능과 고려해야할 사항

SELECT 쿼리의 성능을 월등히 향상시키는 INDEX가 항상 좋은 것일까? 쿼리문의 성능을 향상시킨다는데, 모든 칼럼에 INDEX를 생성해두면 빨라지지 않을까? 결론부터 말하자면 그렇지 않다. 우선, 첫번째 이유는 INDEX를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생한다. INSERT의 경우 INDEX에 대한 데이터도 추가해야 하므로 그만큼 선응에 손실이 따른다. DELETE의 경우 INDEX에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 나멕된다. 즉 row의 수는 그대로인 것이다. 

실제 데이터에 비해 데이터가 과대평가 되는 결과를 낳게 된다. 이렇게 되면 인덱스는 더이상 제 역할을 못하게 될 것이다. UPDATE의 경우 INSERT와 DELETE의 경우 동시에 수반한다. 이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오는 개념이기 대문이다. 

하지만 중요한 것은 칼럼을 이루고 있는 데이터의 형식에 따라 인덱스의 성능이 악영향을 미칠 수 있다는 것이다. 즉, 데이터 형식에 따라 인덱스를 만들면 효율적이고 만들면 비효율적인 데이터의 형식이 존재하게 되는 것이다.

`이름`, `나이`, `성별` 세 가지의 필드를 갖고 있는 테이블을 생각해보자. 이름은 온갖 경우의 수가 존재할 것이며 나이는 INT타입을 갖고, 성별은 남, 녀 두가지의 경우만 생각하면된다. 이 경우 어떤 칼럼에 대해 인덱스를 생성하는것이 효율적일까? 결론 부터 말하자면 이름에 대해서만 인덱스를 생성하면 효율적이다.

값의 range가 적은 성별은 인덱스를 일고 다시 디스크 i/o가 발생하기 때문에 비효율적이다.

**그리고 인덱싱은 검색에 초점을 둔 성능 개선 방식이기 때문에 삭제, 수정, 삽입이 잦은 서비스에는 비효율적일 수 있다.**

