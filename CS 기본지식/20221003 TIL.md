### 데이터

데이터 의 포맷 중 하나인 **JSON**

데이터는 복잡성을 가지는데 이런 데이터를 어떻게 표현하는가 => JSON으로 표현할 수 있다.

JSON(javascript object natation)

자바스크립트 객체 문법으로 구조화된 데이터를 표현하기 위한 표준  포맷입니다.

Javascript의 undefined를 제외한 기본타입과 다른 객체를 포함 할 수 있습니다.

**XML**

sitemap.xml => SEO에 사용된다. **SEO란? 검색 상단에 노출 될 수 있도록 하는것**

sitemap.xml이 왜 필요할까? 구글에는 크롤링 봇이 있다. 각 사이트의 정보를 구글 DB에 저장한다.

크롤링 봇이 사이트 사이트 페이지를 아주 자세하게 저장하기에 사이트에 대한 정보가 노출이 더 잘될 수 있다.

## API (aplication programming interface)

둘 이상의 컴퓨터 프로그램이 서로 통신하는 방법이자 컴퓨터 사이에 있는 중간계층을 의미

과거로부터 발전되어 온 용어로 라이브러리 및 프레임 워크를 설명하는 명세서, 웹상에서는 web api, websocket api 등을 가리키는데 현재를 기준으로는 web api를 기준으로 설명하면 된다.

시청자가 브라우저를 통해서 서버에 요청을 하게 되면 api가 중계계층 역할을 하며 요청을 처리한다. 직접 서버에 접근하는 것을 방지하기도 한다.

### 장점

1. 제공자는 서비스의 중요한 부분을 드러내지 않아도 된다. 
2. 사용자는 해당 서비스가 어떻게 구현되었는지 알 필요 없이 필요한 정보만 받을 수 있다.
3. Open API의 경우 앱 개발 프로세스를 단순화 시키고 시간과 비용을 절약할 수 있다.
4. 제공자의 경우 API를 만들게 되면 내부 프로세스가 수정되었을때 매번 수정하는 것이 아닌 API가 수정이 안되게끔 만들 수 있다. 또한 내부가 변겨오디어도 사용자에게 영향을 주기 않고 변경이 가능하다.
5. 제공자는 데이터를 한 곳에 모을 수 있다.
6. 제공자의 경우 API를 이용해 제 3자가 만들어낸 앱을 이용해 데이터를 수집할 수 도 있고 서비스를 확장해나갈수도 홍보할 수도 있다.

### 종류

- private

  주로 해시키를 이용해 사용한다.

- public

  공개적으로 모든 사람이 사용할 수 있고 트래픽 제한을 위해 요청 수 제한을 걸어두는 경우가 많다.

> Node js란?
>
> 비동기적 이벤트 주도 방식, 논블록킹 I/O 모델을 사용하는 구글의 V8엔진을 장착한 자바스크립트 런타임이다
>
> 런타임이란 프로그램이 실행될 때 프로그램이 머무는 공간을 의미한다. 그래서 자바스크립트로 만든 게임, 알고리즘, 서버 등을 실행 할 수 있다.

## 클라우드

클라우드는 인터넷을 접근 할수 있는 서버 그리고 그 안에서 구동되는 소프트웨어 데이터베이스 등을 의미한다.

나의 컴퓨터 장비를 사용하지 않고 컴퓨터 장비를 구축해 해야할 작업을 온라인에 분산되어 존재하는 데이터 센터에 맡겨 수행하는 것을 말합니다. 이렇게 되면 서버를 직접 구매할때 고려해야할 전력, 위치 , 서버세팅, 확장성을 고민하지 않고 서비스 운영에만 집중할 수 있습니다. 이를 **오프프레미스** 방식이라고 합니다.

### Saas (software as a service)

완제품을 제공합니다. ex) 구글 드라이브, N드라이브, 구글 Docs

어느 환경에서나 동일하게 구동이 가능하다~

### IaaS(infra as a service)

인프라를 제공(서버와 저장소를 줍니다.) 빈방을 주는것 가상머신 위에서 애플리케이션의 각 컴포넌트가 구동됨. 특정 클라우드에 종속 X, 운영비가 상승함. 이식성이 좋음. AWS의 EC2, NCP등이 있음

### Paas(platform as as service)

플랫폼을 제공. 빌트인 방, 운영비를 절감할수 있고, 모니터링 CI/CD가 제공됨. 하지만 IaaS보다는 유연하지 않고 플랫폼에 종속되어 있음. ex) heroku

### IaaS vs PaaS

- IaaS : 서버를 임대 => 어떤 걸 설치하던 상관이 없다. 설치 어렵다. 운영비가 높다. CI/CD, testing, monitoring을 다 직접 설계해야 한다. => 인건비가 추가로 많이 들 것이다.

- PaaS : 하나의 서버에 여러가지를 설치할 수 없다. -> IaaS 덜 자유롭다. 설치 쉽다. 이식이 어렵다. 내가 사용한 서버의 종류나 DB의 종류에 따른 addons을 구매해서 연결해 주어야 해서 어렵다(?)

  운영비가 낮게 든다. => 상대적으로 운영비 절감 효과를 볼 수 있다.

## 도커, 컨테이너

컴퓨터 한대로 여러 개의 앱을 독립적으로 돌릴 수 있다.

> 가상머신
>
> 컴퓨터의 모든 부품을 에뮬레이션 한 것이다. -> 컴퓨터의 하드웨어 적인 부분을 소프트웨어 적으로 올린 것이다. OS가 공유가 되지 않았다.

컨테이너 배포

OS를 공유하고 있다. 컨테이너는 코드와 모든 종속성을 패키징 하는 소프트웨어의 표준 단위입니다. 컨테이너의 '이미지'라고 파일에 모든 라이브러리와 종속성을 포함하는 코드 기반 파일에 저장됩니다.

컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간의 운영체제를 공유하며 가상머신보다 경량화 되어 있습니다. 그렇다고 격리성이 무너지는 것도 아닙니다.

컨테이너나 VM이나 궁극적으로 애플리케이션이 `서로 다른 컴퓨터에 설치되어있다`라고 생각하게 만듭니다. 두 프로그램 간에 간섭을 일으킬 수 없는 장벽을 칩니다.

다만 컨테이너는 OS를 공유하는 방식이기 때문에 애플리케이션의 문제가 OS에 영향을 미치면 OS에서 구동 중인 전체 컨테이너에 문제가 생길 수 있습니다.

### 도커

도커는 앞서 말한 설명한 컨테이너라는 경량 단위로 애플리케이션을 실행하는 기능을 제공하는 플랫폼이며 여러 컴퓨터 간에 공유된 규격으로 리소스를 공유할 수 있어서 유지보수성이 증대 됩니다.

도커는 IaaS의 장점인 이식성, PaaS의 장점인 운영비가 저렴함을 갖춘 도구입니다. 기존 종속적인 라이브러리나 기존 시스템에 대한 설치 절차를 Dockerfile 스크립트에 작성하기만 하고 배포 관련사항을 도커스웜이나 쿠버네티스에 맞춰 작성하기만 하면 됩니다.

보통 `도커 + 쿠버네트스` 또는 `도커 + 도커스웜`으로 구축됩니다.

#### 컨테이너를 만드는 과정

1. 도커 파일이 빌드
2. 도커 이미지 생성 및 실행
3. 도커 컨테이너 실행

- 도커 파일 : 컨테이너에 설치해야하는 패키지, 환경변수 설정 등을 기록한 하나의 파일
- 도커 이미지: 도커가 도커파일의 단계에 따라 컴퓨터의 상태를 '스냅샷'으로 저장한 것.
- 컨테이너 : 도커가 이미지를 불러와 실행할 대 생성된다. 실행중인 컨테이너는 이미지에 지정된 프로그램과 데이터를 사용해 일반적인 실제 컴퓨터와 연결되어 사용가능.

쿠버네티스나 도커스웜 둘 다 컨테이너화된 애플리케이션을 자동으로 배포, 스케일링 및 관리해주는 컨테이너 오케스트레이션입니다.

IaaS의 이식성은 도커 자체의 컨테이너적인 장점으로 발휘되고

PaaS의 운영비 절감 측면은 도커 스웜이나 쿠버네티스가 도움이 된다.

## 정적 타입 시스템의 필요성

개발자는 사용자에게 안정적으로 알맞능 컨텐츠를 서빙하기 위해 여러가지 방법을 씁니다. 서버의 트래픽이 증가하더라도 서버가 다운되지 않게 네트워크 장비에 로드밸러서를 두거나 대역폭을 늘리거나 HA를 하거나 DB샤딩을 하는 등 우리는 여러가지 방법으로 서비스의 안정성을 추구합니다. 그 중 하나의 방법이 정적 타입 시스템입니다.

> 로드밸런서
>
> 서버에 가해지는 부하를 분산해주는 장치 또는 기술을 통칭합니다. 클라이언트와 서버풀 사이에 위치하며 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 퍼포먼스를 보일 수 있도록 합니다.
>
> 트래픽에 대처하는 방법은 2가지 입니다.
>
> 1. scale up
>
>    서버 자체의 성능을 확장하는 것. 즉 성능이 좋은 cpu를 이요하는 것과 비슷합니다.
>
> 2. scale out
>
>    서버를 증설하는 것. 서버를 증설하고 나면 각 각의 서버가 적절히 사용되어 최적을 퍼포먼스를 낼 수 있도록 로드밸런싱하여야 합니다.
>
> 방법
>
> 1. 라운드 로빈
>
>    서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식. 서버와 연결이 오래 지속 되지 않을 경우 적합
>
> 2. 가중 라운드 로빈
>
>    각 서버마다 가중치를 두고 가중치가 높은 서버에 먼저 요청을 배분합니다. 각 서버가 트래픽 처리 능력이 상이한 경우 사용
>
> 3. IP 해시 방식
>
>    클라이언트의 IP 주소를 특정 서벌 매핑하여 처리하는 방식 로드를 사용자의 IP를 해싱해 로드를 분배하기 대문에 사용자가 항상 동일한 서버로 연결되는 것을 보장합니다.
>
> 4. 최소 연결 방식
>
>    요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 배분. 자주 세션이 길어지거나 서버에 분배된 트래픽이 일정하지 않은 경우에 적합
>
> 5. 최소 리스폰 타임
>
>    서버의 현재 연결 상태와 응답시간을 모두 고려하여 배분. 가장 적은 연결상태와 가장 짧은 응답시간을 보이는 서버에 우선적으로 배분

### 타입 시스템이란?

언어의 기본 타입 또는 개발자가 정의한 타입을 기반으로 해당 타입을 언어와 연관 시키는 매커니즘.

- 동등 : 두 타입이 동일할때 적용되는 규칙
- 호환 : 두가지 타입이 정확히 일치하지 않더라도 어느정도 호환이 되는지를 나타내는 규칙
- 추론: 타입이 정의되지 않지만 주변 문맥에 따라 결정이 되는 규칙

동적 타입 : php, js, python 런타임에 모든 변수의 유형을 결정하고 잘못된 경우 예외가 발생

정적 타입 : C , C ++, java 컴파일 타임에 모든 변수의 유형을 결정하고 예외가 발생

동적 타입 언어를 정적 타입 처리되도록 하는 타입스크립트와 같은 것이 유행이다.

### 왜 필요할까?

1. 타입을 명시하여 다른 개발자가 보더라도 어떠한 매개변수를 넣고 어떤 값을 반환하는지 명시적으로 파악할 수 있게 만듭니다.
2. 어떤 함수, 또는 API에 대한 여러가지의 타입으로 이루어진 값이 발생할 수 있는데 해당 값들에 대한 대처를 미리 할 수 있습니다.
3. 매개변수를 잘못 할당하거나 등 개발자의 잔실수를 막아주는 것도 덤입니다.



## 라이브러리 도입 시 고려해야할 점

### Vue vs React

- vue : 반응형 -> input에 대입만으로 값 할당이 가능하다, 양방향 바인딩, html
- react : 함수형 -> 값을 변경하기 위한 함수가 필요하다, 단반향 바인딩, jsx

#### 데이터 바인딩

화면 상의 데이터와 js에서 직접 핸들링하는 데이터가 일치하게 하는것이다. 

vue는 어디에서 바뀌어도 서로 동기화가 되고

react는 인터렉션이 들어오면 이를 따로 함수로 처리해서 내부 데이터를 변경해주어야한다.

### 비교 대상

1. 자유도:  react -> 높음,  vue -> 낮음
2. 의존도 : react -> 높음, vue -> 낮음
3. Doc : react -> 보통, vue -> 쉬움

### 성능

프론트엔드 라이브러리에서 중요한건 DOM에 관련된 성능이다.

Vue가 React보다 성능이 비슷하지만 table에서 row를 선택하거나 swap하는건 vue가 더 좋다.

#### 커뮤니티

얼마나 지속적으로 업데이트가 되는지가 중요하다.

주로 봐야할 것 : 커밋 수, 스타수, 포크수, 기여자수

#### 모바일로서의 확장성



