### 디자인 패턴

프로그램을 설계 할 때 발생했던 문제점 들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약'형태로 만들어 놓은 것을 의미합니다.

### 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴. 데이터베이스 연결 모듈에 많이 사용합니다.

#### 단점

TDD를 할때 걸림돌이 된다. 단위테스트를 주로 하는데 이는 테스트가 독립적이어야 하며 어떤 순서로든 진행할 수 있어야하지만 각 테스트마다 독립적인 인스턴스를 생성하기 어렵습니다.

#### 의존성 주입

싱글톤 패턴은 모듈 간의 결합을 강하게 만들 수 있다는 단점이 있습니다.

이때 의존성 주입을 통해 결합을 조금 더 느슨하게 만들어 해결할 수 있습니다.

장점 : 모듈을 쉽게 교체할 수 있는 구조가 되어 테스팅하기 쉽고 마이그레이션이 수월합니다. 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어 주기 때문에 애플리케이션 의존성 방향이 일관되고, 애플리케이션을 쉽게 추론할 수 있으며 모듈 간의 관계들이 조금 더 명확해집니다.

단점: 모듈들이 분리되므로 클래스 수가 늘어나 복잡성이 증가하며 약간의 런타임 패널티가 존재할 수 있습니다.

#### 원칙

상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야합니다. 또한 둘 다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 말아야합니다.

> 의존성 주입의 예
>
> 셰프라는 클래스가 있고 그 안에 버거레시피라는 메소드가 있다고 하면. 우리는 다양한 버거레시피를 가진 셰프를 만나고 싶어서 버거 레시피마다 새로운 셰프라는 클래스를 만들어야 할 수 도 있다.
>
> 하지만 의존성 주입은 하나의 셰프 클래스에 다양한 의존성 주입을 통해 여러가지 버거 레시피를 가진 셰프를 만들 수 있게 한다.
>
> 셰프라는 생성자 함수의 인자로 여러가지 버거 레시피를 의존성으로 주입하는 방법을 이용할 수 있다.

### 팩토리 패턴

상위 클래스에서는 중요한 뼈대만을 결정하고 하위 클래스에서 객체에 관한 구체적인 내용을 결정하는 패턴입니다.

> 팩토리 패턴의 예
>
> 섬유공장을 상위 클래스로 그리고 면을 만드는 라인, 폴리에스테를 만드는 라인을 각 각 하위 클래스로 두고
>
> 섬유공장 클래스는 라인을 선택하고 돌리는 메서드를 가지고 있고 각 각의 하위 클래스가 구체적으로 어떻게 돌아갈지에 대해 구현되어 있습니다.

그리고 상위 클래스의 하위 클래스를 선택하는 메서드를 `static`으로 지정하면 인스턴스를 만들지 않고 메서드를 호출 가능하기 때문에 메모리가 절약된다.

### 전략 패턴

객체의 행위를 바꾸고 싶은경우 직접 수정하지 않고 캡슐화한 알고리즘을 컨테스트 안에서 바꿔 주면서 상호 교체가 가능하게 만드는 패턴입니다.

> 전략 패턴의 예
>
> 우리가 어떤 사이트에서 로그인을 할때 여러 가지 방법으로 로그인을 할 수 있는데
>
> 로그인이 하나의 객체이고 다양한 전략 패턴이 카카오로그인, 구글로그인, 애플로그인 과 같은 것들이 될 수 있습니다.

#### 전략 패턴과 의존성 주입의 차이

사용하는 의도가 다르다고 할 수 있습니다. 

의존성 주입은 객체의 과도한 의존성을 줄이기 위해 도입된 것이며

전략 패턴은 다양한 알고리즘 패밀리를 형성하고 그 패밀리 내에서 필요한 알고리즘을 선택적으로 사용할 수 있게 하기 위함입니다.

### 옵저버 패턴

어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을때 마다 메서드 등을 통해 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴입니다.

### 프록시 패턴과 프록시 서버

프록시 패턴은 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴입니다.

객체의 속성, 변환 등을 보완하며 보안, 데이터검증, 캐싱, 로깅에 사용합니다.

#### CORS와 프론트엔드 프록시 서버

CORS 에러는 동일 출처 정책을 지키지 않은 리소스를 로드하려할때 브라우저에서 로드하지 못하게 막으면서 발생되는 에러 입니다.

그래서 프록시 서버를 통해 리소스를 로드하고 그 프록시 서버에는 CORS에러를 해결할 수 있게 cross-orgin-allow를 헤더에 추가하면 CORS에러가 더 이상 나지 않는다.

### 이터레이터 패턴

이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴입니다.

이를 통해 순회할 수 있는 여러가지의 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회가능합니다.

### 노출 모듈 패턴

즉시 실행 함수를 통해 `private, public`과 같은 접근 제어자를 만드는 패턴을 말합니다. 

### MVC 패턴

모델, 뷰, 컨트롤러로 이루어진 디자인 패턴입니다. 애플리케이션의 구성요소를 세 가지 역할로 구분하여 개발 프로세승에서 각각의 구성요소에만 집중해서 개발할 수 있습니다. 재사용성과 확장성이 용이하고 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있습니다.

MVC 패턴은 서버 클라이언트 간의 패턴이 아님을 명심해야합니다.

#### 모델

애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 의미

뷰에서 데이터를 생성혹은 변경하면 -> 컨트롤러를 통해 모델을 생성 혹은 갱신

#### 뷰

사용자 인터페이스 요소를 나타냅니다. 모델이 가지고 있는 정보를 따로 저장하지 않아야합니다. 단순히 보여지는 부분의 정보만을 가지고 있어야 합니다.

#### 컨트롤러

하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당합니다. 또한 모델과 뷰의 생명주기도 관리하며 모델이나 뷰의 변경통지를 받으면 이를 해석하여 각각 구성 요소에 해당 내용에 대해 알려줍니다.

> MVC의 예
>
> React의 state or store -> 모델, 각종 로직 -> controller, jsx -> view

### MVP 패턴

MVC패턴으로부터 파생되었으며 C가 Presenter P로 바뀐것으로 보면 될 것 같습니다.

뷰와 프레젠터는 1대1 관계이기 때문에 MVC보다 더 강한 결합을 지닌 디자인 패턴으로 볼 수 있습니다.

### MVVM

MVC에서 C가 VM(View Model)로 바뀌었습니다.

뷰 모델은 뷰를 더 추상화한 계층이며 MVVM 패턴은 MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징입니다. 뷰와 뷰 모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용 할 수 있고 단위 테스팅 하기 쉽다는 장점이 있습니다.

> MVVM의 예
>
> Vuejs
>
> watch, computed 등으로 쉽게 반응형적인 값들을 구축할 수 있습니다.
>
> 값 대입만으로도 변수가 변경되며 양방향 바인딩, html을 토대로 컴포넌트를 구축할 수 있다는 점이 특징입니다.

## 프로그래밍 패러다임

### 선언형과 함수형 프로그래밍

`무엇`을 풀어내는가에 집중하는 패러다임 입니다.

함수형 프로그래밍은 이와 같은 작은 `순수 함수`들을 블록처럼 쌓아 로직을 구현하고 `고차 함수`를 통해 재사용성을 높힌 프로그래밍 패러다임입니다.

> 순수함수란
>
> 외부의 값을 변경하지 않고, 같은 인자를 넣으면 항상 같은 값을 도출하는 함수
>
> 고차 함수
>
> 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것을 말합니다.
>
> 일급객체
>
> - 변수나 메서드에 할당가능
> - 매개변수로 전달가능
> - 반환가능

#### 커링?

함수형 프로그래밍의 특징 중 하나이며 여러가지 인수를 받는 함수를 함수의 연장선으로 연결해서 만들 수 있다

```js
const sum = (a, b) => a + b

function curry(f){
  return function(a){
    return function(b){
      return f(a, b)
    }
  }
}
const curriedSum = curry(sum)
curriedSum(2)(3)   // 5
```

커링을 쓰면 좋을때가 언제일까? 

간단히 비동기를 여러번 하여 받은 결과 값을 어떤 한 함수에 한번에 넣어야 한다고 할때 모든 비동기가 끝나고 넣지말고 각 각 비동기가 끝날때 하나씩 넣어서 적용할 수 있지 않을까 싶습니다.

그리고 기본적으로 가독성이 좋아진다고 생각합니다.

### 객체 지향 프로그래밍

객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식을 말합니다.

#### 특징

추상화 - 핵심적인 개념 또는 기능을 간추려 내는 것을 의미합니다.

캡슐화 - 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것을 말합니다.

상속성 - 상위 클래서의 특성을 하위 클래스가 이어 받아서 재사용하거나 추가, 확장하는 것을 말합니다.

다형성 - 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말합니다 (오버라이드, 오버로드)

> 오버로딩
>
> 같은 이름을 가진 메서드를 여러 개 두는 것을 말합니다. 메서드의 타입, 매개변수의 타입, 개수 등으로 판단
>
> 오버라이딩
>
> 상위 클래스로 상속 받은 메서드를 하위 클래스가 재정의 하는 것을 말합니다.

#### 설계 원칙

단일 책임원칙 - 하나의 클래스는 하나의 책임만을 져야합니다.

개방 폐쇄 원칙 - 수정에는 닫혀있고 확장에는 열려 있어야합니다.

리스코프 치환 원칙 - 상위 클래스를 하위 클래스로 바꾸어도 잘 동작해야합니다.

인터페이스 분리 원칙 - 하나의 일반적인 인터페이스가 아닌 구체적인 여러개의 인터페이스를 만들어야합니다.

의존 역전 원칙 - 상위 클래스가 하위 클래스에 의존해서는 안됩니다.  