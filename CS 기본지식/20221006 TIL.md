##  www.naver.com을 입력시 화면에 나타나기 까지

대기열, 캐싱, DNS, 라우팅, ARP, 초기연결을 거쳐 컨텐츠를 다운받게 되고 이 후 브라우저 렌더링 과정을 거쳐 네이버라는 화면이 나타나게 됩니다. 또한 이런한 과정이 캡슐화, 비캡슐화과정을 거쳐서 이뤄지게 됩니다.

### 대기열

브라우저는 주소창입력에 대한 요청을 대기열에 넣습니다.

### 캐싱

캐싱은 요청된 값의 결과값을 저장하고 그 값을 다시 요청하면 다시 제공한다. 이는 공유프록시 캐시와 브라우저 캐시로 나눠집니다.

#### 브라우저 캐시

쿠키, 로컬스토리지 등을 포함한 캐시입니다. 브라우저 자체가 사용자가 HTTP를 통해 다운로드하는 모든 문서를 보유하는 것을 말합니다. 

#### 공유 프록시 캐시

요청한 서버에서 프록시 서버가 캐싱하는 것을 말합니다. Nodejs로 서버를 구축한다면 앞단의 프록시서버로 nginx서버를 둬서 이 서버를 캐싱 서버로도 사용할 수 있는 것이죠.

### DNS

브라우저가 요청의 IP 주소를 확인하는단계 입니다.

컴퓨터 메모리에 있는 호스트 파일 등 캐시를 확인한 후 캐시미스가 일어나면 DNS서버로 요청합니다.

### IP라우팅 > ARP 진짜 서버를 찾는다.

### 초기연결

TCP 3웨 핸드 쉐이크 및 SSL 연결 등을 통해 연결을 설정합니다. 이후 요청을 보낸후 응답을 받고

### 콘텐츠 다운로드

브라우저는 서버로부터의 응답을 수신합니다.

### 브라우저 렌더링

1. HTML 파일과 CSS파일을 파싱해서 각 각 Tree를 만듭니다. HTML에 CSS 파일도 포함되어 있다면 CSSOM Tree구성 작업도 함께 진행됩니다.

   > 파싱? parser?
   >
   > 어떤 문장을 분석하거나 문법적 관계를 해석하는 행위이다. 즉 여기서의 파싱은 HTML의 파일을 해석하여서 브라우저가 쓰기 쉬운 DOMTree 형식으로 만드는데에 이용됩니다.

   DOM 트리 구축

   하나의 html페이지는 div, span등 각각의 요소를 가집니다. 각 요소는 하나하나 노드로 설정이 되서 트리형태로 저장되는데 이것을 DOM트리라고 합니다.

2. 두 Tree를 결합하여 렌더링 트리를 만듭니다.

   `display: none`이라는 렌더 레이어를 만들때 제외 된다.

3. 렌더링 트리에서 각 노드의 위치와 크기를 계산한다(Layout)

4. 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만든다 (Paint)

5. 레이어를 합성하여 실제 화면에 나타낸다.(Composite)

## HTTP/1.x HTTP2 HTTP3의 차이

### HTTP (Hyper Text Transfer Protocol)

#### HTTP 1.0

하나의 연결 당 하나의 요청을 처리하도록 설계  => RTT 증가 가 생김

> RTT : 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간이며 패킷 왕복 시간

해결하기 위한 방법

- 이미지 스프라이트 

  아이콘을 하나에 여러개를 다운 받은 후 위치 조정으로 재사용하는 기법 

- 코드압축

  개행문자, 빈칸을 없애서 코드의 크기를 최소화하는 방법

- BASE64 인코딩

  이미 파일을 64진법으로 이루어진 문자열로 인코딩 하는 방법입니다. 이미지에 대해 서버에 HTTP 요청을 할 필요가 없다는 장점이 있지만 크기가 37%정도 커지는 단점이 있다.

#### HTTP 1.1

매번 TCP 연결을 하는 것이 아니라 TCP 초기화 한 이후에 keep-alive 옵션으로 여러개의 파일을 송수신할 수 있게 바뀌었습니다.

그래도 해결할 수 없던 문제점이

#### HOL blocking

네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될때 발생하는 성능저하

이미지 패킷이 처음일 경우 다음 패킷이 지연 로딩되는 현상

#### HTTP2

SPDY 프로토콜에서 파생된 HTTP1.X 보다 지연 시간을 줄이고 응답시간을 더 빠르게 할 수 있으며 멀티플렉싱, 헤더압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜 입니다.

> 멀티 플렉싱
>
> 여러개의 스트림을 사용하여 송수신 한다는 것입니다. 이를 통해 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 동작할 수 있습니다.
>
> 스트림
>
> 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가르키는 데이터 흐름

헤더 압축 : 허프만 코딩압축 알고리즘을 사용하는 HPACK 압축형식을 가집니다.

> 허프만 코딩 : 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트 수를 사용하여 표현하고 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현하여 전체 데이터의 표현에 필요한 비트 양을 줄이는 원리가 들어있는 알고리즘 입니다.

서버 푸시

클라이언트가 요청을 하지 않아도 서버가 리소스를 푸시할 수 있다. HTML 파일에는 css 파일이 포함되기 마련이기 때문에 css파일은 서버 푸쉬 해준다.

### HTTP3

TCP 위에서 돌아가지 않고 QUIC이라는 계층 위에서 돌아가며 UDP 기반으로 돌아갑니다.

"초기 연결 설정 시 지연 시간 감소" 대표적인 특징

QUIC은 TCP를 사용하지 않기 때문에 번거로운 3웨이 핸드쉐이크과정을 거치지 않아도 된다.

QUIC은 첫 연결 설정에 1-RTT만 소요된다.

> QUIC 순방향 오류 수정 메커니즘 
>
> 전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식이며 열악한 환경에서도 낮은 패킷 손실률을 자랑합니다.

## HTTPS와 SSL / TLS

HTTPS는 HTTP와 달리 애플리케이션 계층과 전송 계층 사이에 신뢰계층인 SSL/TLS계층을 넣은 신뢰할 수 있는 HTTP를 말합니다. 즉 통신의 암호화 입니다.

### SSL/TLS

SSL1.0부터 발전하여 TLS1.3까지 버전이 올라가며 마지막으로 TLS로 명칭이 변경되었으나, 보통 이를합쳐 SSL/TLS로 부릅니다.

이는 전송 계층에서 보안을 제공하는 프로토콜입니다. 클라이언트가 서버와 통신할대 SSL/TLS를 통해 제 3자가 메시지를 도청하거나 변조하지 못하도록 합니다.

공격자가 서버인척 하며 사용자 정보를 가로채는 네트워크 상의 '인터셉터'를 방지 할 수 있습니다.

클라이언트에서 서버로 사이퍼 슈트를 전달 서버에서 클라이언트로 인증서를 보냄 -> 키교환 알고리즘, 해싱 알고리즘 -> 보안세션 생성 -> 데이터 송수신

#### 보안세션

보안이 시작되고 끝나는 동안 유지되는 세션을 말한다.

> 세션 
>
> 운영제체가 어떤 사용자로부터 자신의 자산 이용을 허락하는 일정한 기간을 뜻한다.

#### 사이퍼 슈트

프로토콜, AEAD 사이퍼모드, 해싱 알고리즘이 나열된 규약

#### 인증 메커니즘

인증 메커니즘은 CA에서 발급한 인증서를 기반으로 이루어집니다.

인증서는 서비스정보, 공개키, 지문, 디지털 서명 등으로 이루어져 있습니다.

참고로 CA는 아무 기업이나 할 수 있는 것이 아니고 신뢰성이 엄격하게 공인된 기업들만 참여할 수 있습니다.

#### 키교환 암호화 알고리즘

디피 - 헬만 키교환 알고리즘

y = g^x mod p 

g와 x와 p를 안다면  y는 구하기 쉽지만 y와 g와 p를 알아도 x는 구하기 어렵다는 원리에 기반한 알고리즘

#### 해싱 알고리즘

데이터를 추정하기 힘든 더 작고 , 섞여있는 조각으로 만드는 알고리즘입니다. 

해시 : 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값

해싱 : 임의의 데이터를 해시로 바꿔주는 일이며 해시 함수가 이를 담당

해시 함수: 임의의 데이터를 입력받아 일정한 길이의 데이터로 반환한다.

## 로그인 방식

HTTP? stateless 하다 연결을 끊는 순간 성태 정보를 유지하지 않는 특성이 있습니다. 

브라우저를 닫을 때 마다 로그인이 풀리나?  로그인을 유지하는 방법인

- 쿠키와 세션
- 토큰기반 방식

### 세션

서버와 클라이언트의 연결이 활성화된 상태

#### 세션 ID

웹 서버메모리에 저장되는 클라이언트에 대한 유니크한 ID

#### 쿠키

키 - 값으로 구성된 작은 데이터 조각

쿠키에 담긴 데이테는 브라우저에서 관리됨. (만료날짜는 서버에서 설정)

이름 값 만료 날짜 등으로 구성

#### 로그인이 유지되는 원리

1. 처음 로그인 > 쿠키, 세션 ID 생성 그 이후 다시 요청했을때 HTTP 헤더에 쿠키를 포함시켜 요청한다.
2. 그리고 해당 쿠키에 맞는 세션 ID로 전에 로그인 했던 아이디인지 확인
3. 로그인 유지

쿠키는 클라이언트에서 js로 조회가능 그래서 공격자들이 쿠키를 가로채고자 시도를 하게 되는데 이를 XSS(cross site scripting)이라고 하고

해결방법 : HTTP-only cookie또는 secure cookie를 사용함.

`axios.defulats.withCredentials = true` 하자.

앞서 세션-쿠키를 이용한 로그인 유지의 단점

1. 로그인 중인 유저의 수가 늘어나면 서버의 메모리 과부화가 생길 수 있다.

   이를 해결하기 위해 JWT토큰을 이용한 토큰기반 인증 방식을 이용할 수 있다.

#### 토큰 기반 인증 방식

JWT 토큰이 대표적

인증은 토큰기반인증서버를 통해서 하게 하고

서버는 stateless하게 내버려두고

요청 > 토큰생성 > 이후 사용자가 토큰을 헤더에 넣어서 보내면 서버에서 유효한지 확인한다.

#### JWT 토큰

header, payload, signature로 이루어져 있습니다.

header

어떠한 방법의 서명 알고리즘을 사용할 것인가에 대한 정보

payload

데이터 토큰 발급자, 토큰 유효기간

signature

헤더에 정의된 알고리즘으로 인코딩된 헤더와 페이로드를 합친값, 그리고 비밀키를 기반으로 생성된 서명값.

#### 장점

사용자가 인증되면 모든 시스템에서 사용할 수 있는 보안 토큰을 받습니다. 즉, 단일 엔드포인트를 생성해서 다른 모든 서버간의 API 상호작용을 인증할 수 있다.

별도의 인증 저장소가 필요 X 

사이즈가 작다

#### 단점

더 많은 필드가 추가되면 토큰이 비대해져 트래픽에 영향

탈취하여 디코딩 하면 데이터를 볼 수 있음

## 로컬 스토리지와 세션 스토리지

오리진에 종속되어있다

> origin : protocol + host ( hostname + port )

### 로컬 스토리지

키와 쌍 형태로 입력하고 창을 닫아도 없어지지 않는다.

특징

만료날자 없고 최대 10MB 자동으로 서버에 전송되지 않는다.

### 세션 스토리지

탭을 닫을때 삭제되고 최대 5MB

## 쿠키

클라이언트에 데티어를 저장하는 방법 중 하나. 쿠키는 요청을 할 때 서버에 자동으로 전송됨. 

set-cookie 헤더에 설정된 작은 데이터 조작 4kb까지 가능

#### 세션 쿠키

expires 또는 Max-age와 같은 속성을 지정하지 않은것. 브라우저가 닫힐 때 제거됩니다.

#### 영구쿠키

expires 또는 Max-age와 같은 속성을 지정한 것. 이 쿠키는 브라우저를 닫을때 만료되지 않지만 특정 날짜 또는 일정기간이 지나면 제거 됩니다.

#### secure

https로만 가능 

1. httponly

   공격자가 자바스크립트로 빼낼 수 없음(document.cookie로 접근 불가)

2. samesite = strict

   요청이 동일한 도메인에서 시작된 경우에만 쿠키가 애플리케이션으로 전송되도록 허용

#### 세션 ID 설정시

세션 ID 기반을 클라이언트 인증정보를 알 수 없게 해야 함. httponly, 세션 타임아웃을 걸어야함.

### 로컬 스토리지, 세션 스토리지, 쿠키의 차이

필요한 이유

1. 서버에 대한 요청을 줄임
2. 네트워크 연결 없이 웹사이트를 더 빨리 다운로드

저장목록

- 사이트 기본 설정 커스터 마이징
- 로그인 상태 저장

## HTTP 상태 코드와 메서드

1xx : 요청을 받았으며 포르세스를 계속한다.

2xx : 요청을 성공적으로 받았으며 인식했고 수용합니다.

- 200 ok : 요청이 성공적으로 되었습니다.
- 201 created : 요청이 성공적이었으면 그 결과로 새로운 리소스가 생성되었습니다.

3xx : 요청 완료를 위해 추가 작업조치가 필요하다.

- 301 moved permarnently : 리소스의 uri가 변경되었음을 의미합니다. 변경된 새로운 uri를 응답에서 주는 것이 좋습니다.

4xx : 잘못된 문법에 의해 요청을 처리할 수 없다. 

- 400 bad request : 잘못된 문법으로 인해 서버가 요청을 이해할 수 없음을 의미
- 401 unauthorized : 클라이언트의 인증이 되지 않음을 의미합니다.

5xx : 서버가 명백히 유효한 요청에 대해 충족을 실패함을 의미

- 500 internal server error : 서버에 오류가 있음을 의미합니다.

### 메소드

- get

  읽기, 성공 시  200 상태 반환. 오류의 경우 404(not found) 또는 400(bad request)반환

  데이터 수정, 삭제 시 사용하면 안됨

- post

  자원을 생성, 보통 하위자원을 생성 성공하면 HTTP 상태 201을 반환

- put

​		요청을 보낼 때 전체를 보내야함

- patch

  요청을 보낼 때 수정하는 일부분을 보내야함.

- delete

  삭제