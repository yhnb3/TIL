### 트랜잭션 격리수준에 따른 현상

#### 팬텀리드

한 트랜잭션 내에서 동일한 쿼리를 2번 이상 보냈을때 해당 조회 결과가 다름.

#### 반복가능하지 않은 조회

한 트랜잭션 내의 같은 행에 두번 이상조회가 발생 했는데 그 값이 다른 것을 말합니다.

#### 더티리드

하나의 트랜잭션이 다른 트랜잭션의 아직 커밋되지 않는 데이터를 읽는 현상입니다.

#### 격리 수준

- Read Uncommitted : 더티리드, 반복가능하지 않은 조회, 팬텀리드 다 발생 할 수 있다.
- Read Committed : 반복가능하지 않은 조회, 팬텀리드 발생할 수 있다.
- Repeatable Read : 팬텀리드 발생 할 수 있다.

- Serializable : 발생하는 현상 없당.

#### Serializable

커밋 완료된 데이터에 대해서만 조회할 수 있으며 트랜잭션을 순차적으로 진행시키는것. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없습니다.

#### Repeatable

커밋 완료된 데이터에 대해서만 조회할 수 있으며 반복해서 행을 조회하더라도 똑같은 행을 보장하는 단계입니다. 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않습니다.

#### Read_commited

커밋 완료된 데이터에 대해서만 조회할 수 있으며 커밋되지 않은 정보는 읽지 못합니다.

#### Read_uncommited

가장 낮은 격리 수준이며 가장 빠르다. 다른 트랜잭션이 커밋하지 않은 정보를 읽을 수 있습니다.

### 관계형 데이터 베이스와 NoSQL의 차이

#### 관계형 데이터 베이스

RDBMS는 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스를 가리키며 SQL이라는 언어를 써서 조작합니다.

#### NoSQL 데이터베이스

Not Only Database라는 슬러건에서 생겨난 데이터 베이스입니다. SQL을 사용하지 않는 데이터베이스를 말하며 유연한 스키마, 확장성이 특징입니다.

#### MongoDB

1. key value 형태의 도큐먼트

   mongoDB : json형태로 쿼리를 만들고 bjon형태로 저장한다.

2. 스키마 없이 삽입 가능

3. 데이터 조합합수 지원

4. 이중화 지원과 샤딩

5. 2차원 좌표 인덱싱

6. collection join

### 스토리지 엔진

#### innoDB

myisam에 비해 데이터베이스가 커짐에 따라 더 큰 가용성 제공

행 인덱스 조회 캐싱할때 엔진 자체 내에서 행 캐시와 인덱스 캐시를 결합

#### MyISAM

#### wiredtiger

LSM트리 기반 읽기 성능을 포기하고 저장 성능을 향상

읽기 선응을 보완하기 위해 블룸 필터를 사용한 엔진입니다.

로깅 가능

### 인덱스의 구조와 효율적인 이유

#### 인덱스란?

데이터를 빠르게 찾을 수 있는 하나의 장치. 

#### 효율적인 이유?

균형잡힌 B-Tree 기반으로 구축되어 있어서 탐색에 평균 O(logN) 시간이 걸리며 트리 생성시 대수확장성이란 특징으로 인해 더 빠른 시간안에 많은 데이터를 찾을 수 있기 때문이다.

> B-tree
>
> 루트 노드, 리프노드, 브랜치노드로 이루어져 있으며 이진 트리를 확장해 하나의 노드가 가지 수있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조를 가진 균형잡힌 트리를 발합니다.

> 대수 확장성
>
> 트리의 높이가 리프 노드수에 비해 매우 느리게 성정하는 것을 말합니다. 즉 트리의 깊이가 아주 조금 높아져도 매우 많은 데이터를 저장할 수 있기때문에 매우 효율적이다.

### 인덱스 최적화 기법

1. 인덱스는 비용이다. 

   인덱스는 2번 탐색하도록 강요합니다. 인덱스 리스트 그 다음 컬렉션 순으로 탐색하기 때문에 비용이 많이 든다. 컬렉션이 수정되었을때 인덱스도 수정되어야 합니다. B-tree를 균형있게 조절하는 데도 비용이 들고 데이터를 효율적으로 조회할 수 있도록 분산하는 것도 비용이 듭니다.

2. 항상 테스트이하라

3. 복합 인덱스는 같은, 정렬, 다중 값, 카디널리티 순이다.

### Clustered Index

유일성과 최소성을 가지는 기본키 중 하나로 설정. 테이블당 한개, 보통 테이블의 기본키가 클러스터형 인덱스가 됩니다.

데이터 페이지가 정렬되서 저장되며 인덱스 페이지의 리프노드에 데이터 페이지가 들어가 있음. 정렬되었기 때문에 탐색에 장점

데이터가 추가될 때마다 다시 모든 테이블을 정렬해야하기 때문에 삽입, 삭제, 수정이 느림

다음 그림 처럼 테이블 레코드와 인덱스의 순서가 같게 조절됨.

#### no clustered Index

보조인덱스라고 함, 한개가 아닌 여러개를 만들 수 있음. 클러스터 형키가 복합키가 될수도 있긴하나 보통 복합키를 만든다고 했을때 보조인덱스로 만듬

인덱스 페이지 리프노드에 실제 데이터가 있는것이 아니라 데이터 페이지에 대한 포인터가 잇음.

정렬되어있지 않아 탐색은 느리나 삽입, 삭제, 수정은 빠름.

인덱스의 순서와 데이터의 순사가 일치하지 않음.

## 조인

두개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 말합니다.