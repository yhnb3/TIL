## 디자인 패턴

프로그램을 설계할때 발생했던 문제점 들을 객체 간의 상호 관계등을 이용하여 해결할 수 있도록 하나의 `규약`형태로 만드는 것.

### 라이브러리 vs 프레임워크

**라이브러리**

공통으로 사용될 수 있는 특정한 기능들을 모듈화 한것을 의미한다. 프레임워크에 비해 사용이 자유롭다. 사용법이 자유롭다(?)

**프레임워크**

공통으로 사용될 수 있는 특정한 기능을 모듈화 한 것을 의미한다. 폴더명 파일명 등에 대한 규칙이 있으며 사용법이 라이브러리에 비해 엄격하다.

### 싱글톤 패턴

하나의 클래스로 하나의 인스턴스만을 가지는 패턴. 보통 데이터 베이스 연결 모듈을 많이 사용합니다.

#### 장점

하나의 인스턴스를 기반으로 해당 인스턴스를 다른 모듈들이 공유하여 사용하기 때문에 인스턴스를 생성할때 드는 비용이 줄어듭니다. 그렇기 때문에 `인스턴스 생성에 많은 비용`이 드는 I/O바운드 작업에 많이 사용합니다.

> I/O 바운드란?
>
> 네트워크, DB, 파일시스템에 하는 요청은 I/O바운드라고 할 수 있다. 시간이 많이 걸리는 작업이다.
>
> 입출력 장치에 의존하는 알고리즘이다..(?)

ex) 서버와 DB컨테이너는 따로 존재하기 때문에 서버에서 DB에서 데이터를 select하려할때 매번 연결하면 너무 많은 리소스(?)를 사용하게 되기 때문에 싱글톤 패턴으로 최초로 연결된 인스턴스로 계속해서 이용하면 매번 연결하는 것을 방지 하여 성능면에서 더 좋아 질 수 있다.

#### 단점

의존성이 높아지며 TDD를 할때 걸림돌이 된다.TDD를 할때 단위테스트를 주로하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야한다.

하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 테스트마다 `독립적인`인스턴스를 만들기가 어렵습니다.

## 의존성 주입

싱글톤 패턴의 높은 의존성을 줄이기 위해 의존성 주입을 통해 모듈간의 결합을 조금 더 느슨하게 만들 수 있다.

메인 모듈이 '직접' 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존선 주입자가 이 부분을 자로채 메인 모듈이 '간접'적으로 의존성을 주입하는 방식이자. 서비스를 사요하려는 클라이언트가 해당 서비스의 구성 방법을 알 필요가 없게 하는 방식.

#### 장점

1. 모듈들을 쉽게 교체할 수 있고 테스팅 하기 쉽고 마이그레이션 하기도 수월하다.

   > 마이그레이션이란?
   >
   > 한 운영환경으로부터, 대개의 경우 좀 더 나은 환경으로 옮겨가는것
   >
   > ex) jquery 기반 => react 기반

2. 애플리케이션 의존성 방향이 좀 더 일관적이게 된다.

   의존성 주입이라는 것을 기준으로 좀 더 쉽게 구조 파악할 수 있다.

3. 객체들을 쉽게 교체할 수 있는 코드가 됨.

#### 단점

모듈들이 더욱 더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있음. (클래스 폭발이라고 함?)

의존성을 주입하기 위해 준비해야 할 준비물들이 많이 늘어나게 될 수 밖에 없다.

## 팩토리 패턴

팩토리 패턴은 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴입니다.

상위 클래스와 하위 클래스가 분리되기 대문에 느슨한 결합을 가지며 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 갖게 됩니다.

객체 생성 로직이 따로 떼어져 있기 때문에 코드를 리팩토링 하더라도 한 곳만 고칠수 있게 되니 유지 보수성이 좋아집니다.

> static 으로 만드는 메서드를 정적 메서드라고 한다.
>
> 정적 메서드를 쓰면 클래스의 인스턴스 없이 호출이 가능하며 메모리를 절약할 수 있고 개별 인스턴스에 묶이지 않으며 클래스 내의 함수를 정의할 수 있는 장점이 있습니다.

## 이터레이터 패턴

이터레이터를 사용하여 컬렉션의 요소들엑 접근하는 디자인 패턴입니다. 각기 다른 자료형의 구조와는 상관없이 이터레이터 라는 하나의 인터페이스로 순회가 가능해서 코드의 효율화.

## 전략 패턴

전략 패턴은 정책 패턴이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴입니다.

> 컨텍스트
>
> 프로그래밍에서 컨텍스트는 상황, 맥락, 문맥을 의미하면 개발자가 어떠한 작업을 완료하는데 필요한 모든 관련 정보를 말한다.

ex) 다양한 방식으로 로그인 구현할때 `login()`이라는 메서드 안에 `googleStrategy, kakaoStrategy`와 같은 다양한 전략을 바꿔 넣음으로써 동작이 가능하게끔 구현하는 패턴

## 옵저버 패턴

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을때 마다 메서드 등을 통해 옵저버 목록에 있는 옵저버 들에게 변화를 알려주는 디자인 패턴입니다.

주체란 객체의 상태변화를 보고 있는 관찰자이며, 옵저버들이란 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 '추가 변화 사항'이 생기는 객체들을 의미합니다.

ex) 내가 어떤 사람을 팔로우를 하면 그 사람의 팔로워에 내가 추가 되어야 한다.

#### MVC 패턴에서의 활용

주체가고 볼 수 있는 모델에서 변경사항이 생겨서 `update()`메서드로 옵저버인 뷰에 알려주고 이를 기반으로 컨트롤러가 작동한다.

## 프록시 패턴

대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴입니다. 

이를 통해 객체의 속성, 변환 등을 보완하며 `보안, 데이터 검증, 캐싱, 로깅`에 사용합니다. 대표적으로는 프록시 서버를 예로 들 수 있습니다.

#### 프록시 서버

프록시 서버는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가르킵니다.

> CORS와 프록시 서버
>
> CORS란 서버가 웹 블라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘 입니다.
>
> 프론트엔드 개발시 프론트엔드와 백엔드와 통신할 때 CORS 에러가 발생하곤 하는데 이를 해결하기 위해 프록시 서버를 만들기도 합니다.
>
> 오리진이란?
>
> 프로토콜과 호스트이름 포트의 조합을 의미합니다.

## MVC, MVP, MVVP

### MVC

모델 뷰 컨트롤러로 이루어진 디자인

애플리케이션의 구성요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있습니다. 재사용성과 확정성이 용이하다는 장점이 있고 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해질 수 있습니다.

#### 모델

애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻합니다. 모델인 데이터를 의미한다.

#### 컨트롤러

컨트롤러는 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트등 메인 로직을 담당합니다. 

#### 뷰

사용자 인터페이스 요소를 나타냅니다. 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻합니다. 변경이 일어나면 컨트롤러를 통해 모델에 이를 전달해야 합니다.

Ex) 리액트, 쟝고

### MVP

MVC 패턴으로 부터 파생되었으며 컨트롤러가 프레젠터(presenter)로 변경되었습니다.

뷰와 프레젠터는 1 대 1 관계입니다.

### MVVM

MVC에서 C가 VM(view model)로 변경된 패턴입니다. 여기서 뷰 모델은 뷰를 더 추상화한 계층이며(vm과 v의 관계는 1: N), MVVM패턴은 MVC패턴과 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징입니다. 뷰와 뷰 모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅 하기 쉽다는 장점이 있습니다.

> 커맨드
>
> 여러가지요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법이다. VM에 명령 요청을 ㄱ객체의 형태로 캡슐화 하여 나중에 이작업을 수행 및 트리거 할 수 있도록하는 패턴
>
> 데이터 바인딩
>
> 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로 뷰 모델을 변경하면 뷰가 변경됩니다.

ex) vue, android

이러한 패턴의 목표는 애플리케이션에 대한 시각화, 데이터 처리 등 관리의 책임을 분리하는 것입니다. 이러한 패턴들은 결국 "어떻게 나눌 것인가"에 대한 해답 중 하나입니다.

### Flux

mvc 패턴의 한계로 페이스북이 만듬.

모델의 많은 데이터 중 하나의 변경이 여러개의 뷰에 영향을 끼친다면 아마 모델과 뷰의 관계가 매우 복잡해 질 것이다. 이는 반대로도 적용될 수 있는 문제이다. 그래서 이런 것을 보완하기 위해 만들어진 것이 flux 패턴이다.

단방향 데이터 흐름을 활용하여 복잡한 뷰 구성을 단순화한 디자인 패턴. action, dispatcher, store 계층이 있음 데이터 일관성이 늘어나고 버그를 찾기 쉬워지며 단위 테스팅이 쉬워지는 장점이 있음.

#### Action

이벤트가 발생했을때 Action에 관한 객체를 만들어내어 dispatcher에게 전달

#### Dispatcher

Dispatcher는 들어오는 Action 객체 정보를 기반 어떠한 "행위"를 할 것인가. 보통 action객체의 type을 기반으로 미리 만들어 놓은 로직을 수행한다. 

#### Store

데이터, 상태를 담고 있는 계층

Redux가 flux패턴을 기반으로 만들어 졌다.

## 의존성 주입 vs 전략 패턴

전략 패턴 : 의도에 초점을 맞추고 동일한 행동 계약을 준수하는 다양한 구현으로 인터페이스를 만들도록 권장하는 것을 포함

의존성 주입 : 단지 일부 동작을 구현하고 의존성을 주입하기만 하는 패턴입니다.

## 컨텍스트란

1. 어떤 종류의 상태 환경을 캡슐화 한것
2. 작업이 중단되고 나중에 같은 지점에서 계속 될 수 있도록 저장하는 최소 데이터의 집합

컨텍스트는 context와 context information으로 나눠진다.

http 요청을 하는 context에서 http 헤더와 바디는 contextual information이라고 할 수 있다.

## 자바스크립트의 class

클래스

클래스는 객체를 생성하기 위한 템플릿입니다. 

객체를 만드는 틀 과 같은 것입니다.

객체가 컴퓨터 메모리 위에 올라가면 그것은 인스턴스라고 한다.

static을 쓰는 이유

1. 중복되는 함수 데이터를 정의 할때 (메모리 이점)
2. 이 클래스의 객체들 끼리 사용되는 메서드나 속성이다. 라는 명시성이라는 장점이 있음.

#### static변수를 남발하면 뭐가 안좋을까?

static 변수는 일종의 전역 변수이다.

하지만 전역 변수와는 다르게 get, set 함수를 만들 수 있고 클래스에서 사요ㅕ된다는 점이 다르다.

- 동시성문제 여러 스레드에서 해당 전역 변수를 참조 하게 된다면 static변수가 변경되면 다른 모든 스레드에 영향을 줄 수 있기 때문에 사이드 이펙트에 대한 안전성을 보장하지 못한다.
- 메모리 문제 : 클래스가 생성될때 메모리를 할당 그리고 종료시점에 반홤되므로 사용하지 않아도 메모리에 할당되어 있다.
- 테스트 문제 : static 변수 자체가 단위적이지 않고 전역적으로 관리 되기 때문에 해당 부분을 깨끗하게 테스팅 하기 어렵습니다.