## 프라미스 패턴

프라미스에 기반을 두고 좀 더 추상화한 형태로 구축 가능한 비동기 패턴의 변형이 많다.

#### Promise.all

복수의 비동기 처리를 병렬적으로 시행하는 패턴이다.

```js
const p1 = request("http://some.url.1")
const p2 = request("http://some.url.2")

Promise.all([p1, p2])
.then((msgs) => {
  return request(
  	"http://some.url.3/?v=" + msgs.join(",")
  )
}, () => console.log(1))
.then((msg) =>{
  console.log(msg)
})
```

여기서 `msgs`는 `p1`, `p2`의 이룸 메시지의 배열이다.

`Promise.all([])`의 메인 프라미스는 자신의 하위 프라미스들이 모두 이루어져야 이루어질 수 있다. 하나의 프라미스라도 실패하면 메인 프라미스 역시 곧바로 버려지며 다른 프라미스의 결과도 덩달아 무효가 된다.

프라미스마다 항상 버림/에러 차리기를 붙여넣도록 습관화 하자. 특히 `Promise.all([])`이 내어준 프라미스는 더더욱 잊지말자.

#### Promise.race([])

여러 프라미스를 동시에 편성하여 모두 이루어진다는 전제로 작동하는데 `결승선을 통과한 최초의 프라미스만` 인정하고 나머지는 무시해야 할 때도 있다.

예전부터 이른바 `걸쇠` 라는 패턴으로, 프라미스에서는 경합이라고 한다.

이 또한 하나라도 이루어진 프라미스가 있을경우에 버려지고 하나라도 버려지는 프라미스가 있으면 버려진다.

폐기/무시되는 프라미스들은 어떻게 될까?

성능관점이 아닌 작동 관점에서 바라보아야한다. foo()라는 함수에 어떤 자원을 이용하려고 예약된 상태인데 먼저 timeout이 걸린다면? 이런 패턴에서 타임아웃 직후 예약된 자원을 선제적으로 다시 놓아주거나 이 자원에 있을 부가효과를 취소할 방법이 없을까?

```js
if(!Promise.observe) {
  Promise.observe = (pr, cb) => {
    pr.then(
      (msg) => {
        Promise.resolve(msg).then(cb)
      },
      (err) => {
        Promise.resolve(err).then(cb)
      },
  }
}

Promise.race([
  Promise.observe(
  	foo(),
    (msg) => {
      // foo()가 제시간에 끝나지 않아도 뒷정리를 한다.
    }
  ),
  timeoutPromise(3000) // 3초 준다.
])
```

`Promise.observe`를 이용할 수 있다. 다수의 프라미스들이 서로 간섭하지 않고도 완료 여부를 감지할 수 있게 해주는 유틸리티의 예이다. 

#### all([]) , race([])의 변형

- none([])

  all과 비슷하지만 이룸/버림이 반대이다. 따라서 모든 프라미스는 버려져야 하며, 버림이 이룸값이 되고 이룸이 버림값이 된다.

- any([])

  all과 유사하나 버림은 모두 무시하며, 하나만 이루어지면 된다.

- first([])

  any의 경합과 빗슷하다. 일단 최초의 프라미스가 이루어지고 난 이후에 다른 이룸/버림은 무시한다.

- last([])

​		first([])와 거의 같고 최후의 이룸 프라미스 하나만 승자가 된다는 것만 다르다.

