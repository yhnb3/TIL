## 데너블 덕 타이핑

진짜 프라미스는 `then()`메서드를 가진 `데너블 - thenable`이라는 객체 또는 함수를 정의 하여 판별하는 것으로 규정됐다. 데너블에 해당하는 값은 무조건 프라미스 규격에 맞다고 간주하는 것이다.

> 덕타이핑
>
> 어떤 값의 타입을 그 형태를 보고 짐작하는 타입체크를 일반적인 용어로는 덕 타이핑이라고 한다. 
>
> ex) 오리처럼 생겼고 오리 처럼 꽥꽥 소리를 내면 오리임에 틀림이 없다.

덕 타이핑으로 데너블 체크를 하면 다음과 같다.

``` 
if (p !== null && (typeof p === 'object' || typeof p === 'function') && typeof p.then === 'function') {
  // 데너블
} else {
  // 데너블 아니다.
}
```

### 프라미스 믿음

그럼 우리가 앞서 콜백에서 언급했었던 제어의 역전으로 생기는 불신이 어떤 것이 있을까?

- 너무 일찍 호출
- 너무 늦게 호출
- 너무 적게 혹은 너무 많이 호출
- 필요한 환경/인자를 제대로 전달 못함.
- 발생 가능한 에러/예외 무시함.

프라미스는 이러한 것들을 모두 유용하게 그리고 되풀이하여 쓸 수 있도록 설계 되었다.

#### 너무 빨리 호출

프라미스는 바로 실행되더라도 프라미스의 정의상 동기적으로 볼 수 없으니 이 문제는 영향 받을 일이 없다.

따라서 `then()`을 호출하면 프라미스가 이미 귀결된 이후라 해도 `then()`에서 건넨 콜백은 항상 비동기적으로만 부른다.

굳이 `setTimeout(..., 0)`과 같은 꼼수는 필요 없다. 프라미스는 자르고를 알아서 예방한다

#### 너무 늦게 호출

프라미스 `then()`에 등록한 콜백은 새 프라미스가 생성되면서 `resolve(), reject()`중 어느 한쪽은 자동호출하도록 스케줄링 된다. 이렇게 스케줄링된 두 콜백은 다음 비동기 시점에 예상대로 실행될 것이다.

즉, 프라미스가 귀결되면 `then()`에 등록된 콜백들이 그 다음 비동기 기회가 왔을때 순서대로 실행되며 어느 한 콜백 내부에서 다른 콜백의 호출에 영향을 주거나 지연 시킬 일은 있을 수 없다.

#### 한번도 콜백을 안 호출

프라미스로 해결 가능하다.

우선 프라미스 스스로 귀결 사실을 알리지 못하게 막을 방도는 없다.

물론 콜백 자체에 자바스크립트 에러가 나면 결과가 이상하게 나오겠지만 그래도 어쨋든 콜백은 호출된다. 콜백에서 난 에러가 묻혀서는 안 되므로 잠시 후 콜백에서 발생한 에러를 알림 처리하는 방법을 살펴보자.

어느쪽으로 귀결되지 않더라도 경합이라는 상위 수준의 추상화를 통해 해결가능하다.

```js
function timeoutPromise(delay) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject('time out!')
    }, delay)
  })
}

Promise.race([
  foo(),
  timeoutPromise(500)
])
.then(
	() => {
    // foo()가 제시간에 이루어졌습니다.
  },
  (err) => {
    // 'foo()가 버려졌거나 제시간에 실행안됨'
    // 'err'를 조사하여 진상규명 해야댐
  }
)
```

#### 너무 가끔, 너무 종종 호출

프라미스는 정의상 단 한번만 귀결된다. 어떤 이유로 프로미스 생성 코드가 `resolve, reject`를 자주 호출 하려고 하면 오직 최초의 귀결만 취하고 나머지는 무시한다.

물론 `p.then(); p.then()`하면 여러번 호출이 된다. 

#### 인자/환경 전달 실패

프라미스 귀결 값은 딱 하나뿐이다.

명시적인 값으로 귀결되지 않으면 그 값은 `undefined`로 세팅된다. 하지만 값이야 어떻든, 지금이든, 나중이든 프라미스는 모든 등록한 콜백으로 반드시 전해진다.

여기서 주의할점은 `resolve(), reject()` 함수를 부를때 인자를 여러개 넘겨도 두번째 이후 인자는 그대로 무시한다. 앞에서 이야기한 보장 체계를 위반한 것처럼 보이지만 엄밀히 따ㅈ면 프라미스 체계를 잘못사용한 대가이다. 

값을 여러개 넘기고 싶다면 배열이나 객체로 꼭 감싸야한다.

자바스크립트 함수는 자신이 정의된 스코프의 클로저를 항상 간직하므로 클로저를 통해 얼마든지 계속 주변 상태에 접근할 수 있다.

#### 에러/예외 삼키기

프라미스가 생성 중 또는 귀결을 기다리는 도중 언제라도 `TypeError, ReferenceError`등의 자바스크립트 에러가 나면 예외를 잡아 주어진 프라미스를 강제로 버린다.

#### 미더운 프라미스?

의심에 여지없이 프라미스는 콜백을 완전히 없애기 위한 장치가 아니다. 단지 프라미스는 콜백을 넘겨주는 위치만 달리할 뿐이다. `foo()`에 콜백을 바로 넘기지 않고 `foo()`에서 뭔가(진짜 프라미스)를 반환받아 이 `뭔가`에 콜백을 전하는 것이다.

그런데 콜백만 사용할 경우보다 더 미덥다고 느끼는 이유는 뭘까? 반환받은 `뭔가`가 실제로 미더운 프라미스라고 어떻게 장담할 수 있을까?

이와 같은 의문에 종지부를 찍을 해결책은 이미 프라미스에 구현되어 있다. 그 주인공은 바로 `Promise.resolve()`이다.

즉시값 또는 프라미스 아닌/ 데너블 아닌 값을 Promise.resolve()에 건네면 이 값으로 이루어진 프라미스를 손에 넣게 된다.

```js
const p1 = new Promise((resolve, reject) => resolve(42))
const p2 = Promise.resolve(42)
```

p1과 p2는 똑같은 결과 값을 가지게 된다.

더욱 중요한 사실은 프라미스가 아닌 데너블 값을 `Promise.resolve()`에 주면 일단 그 값을 풀어보고 최종적으로 프라미스가 아닌 것 같은 구체적인 값이 나올때 까지 풀어본다는 것이다.

`Promise.resolve()`는 데너블 인자로 받아 데너블 아닌 값이 발견될 때까지 풀어봐서 믿을 만한 진짜 순종 프라미스를 즉석에서 내놓는다. 진짜 프라미스 값을 넘기면 도로 내놓으니까 믿음성을 확보하기 위해 `Promise.resolve()`를 거친다 해도 단점이 전혀 없다.

### 연쇄흐름

프라미스는 장난감 블록 같아서 여러개를 길게 늘어놓으면 일련의 비동기 단계를 나타낼 수 있다.

비결은 프라미스에 내재된 두 가지 작동 방식이다.

- 프라미스에 `then()`을 부를때 마다 생성하여 반환하는 새 프라미스를 계속 연쇄할 수 있다.
- `then()`의 이룸 콜백 함수가 반환한 값은 어떤 값이든 자동으로 (첫번째 지점에서) 연쇄된 프라미스의 이룸으로 세팅된다.

이 두 특성의 의미를 먼저 이해하고 어떻게 활용할지 알아보자

```js
const p = Promise.resolve(21)
const p2 = p.then((v) => {
  console.log(v)  // 21
  // p의 이룸 값은 21 p2의 이룸 값은 21 * 2 -> 42
  return v * 2
})

p2.then((v) => console.log(v))  // 42
```

```js
const p = Promise.resolve(21)
p.then((v) => {
  console.log(v)
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(v*2), 100)
  })
})
.then((v) => {
  console.log(v)  // 100ms 이후에 42
})
```

결국 프라미스로 리턴되는 것은 `then`으로 귀결하면 계속해서 프라미스가 아닌 어떤 값으로 반환되게끔 되어있다.

흐름을 제어할 수 있는 프라미스의 고유 특징을 정리해보자.

- then()을 호출하면 그 결과 자동으로 새 프라미스를 생성하여 반환한다.
- 이룸/버림 처리기 안에서 어떤 값을 반환하거나 예외를 던지면 이에 따라 새 프라미스가 귀결된다.
- 이룸/버림 처리기가 반환한 프로미스는 풀린 상태로 그 귀결 값이 무엇이든 간에 결국 현재의 `then()`에서 반환된 연쇄된 프라미스의 귀결 값이 된다.

### 에러처리

흔히 아는 try ... catch 로는 비동기 에러처리를 할 수 없다. 그래서 버림 처리기로 처리하는 문제를 한번 보겠습니다.

```js
const p = Promise.reject('허걱')

p.then(
  function fullFilled() {
  	// 실행되지 않는다
	}, 
  function rejected(err) {
  	console.log(err) // 허걱
  }
)
```

아무 명쾌해보인다. 하지만 프라미스 에러처리는 미묘한 부분이 숨겨져 있어서 완벽하게 이해하기는 쉽지 않다.

```js
const p = Promise.resolve(21)

p.then(
	function fullFilled(msg) {
    console.log(msg.toLowerCase())
    // msg는 string이 아니므로 에러가 날 것이다.
  },
  function rejected(err) {
    console.log(err)
    // 실행안함.
  }
)
```

이렇게 보면 `p.then()`이 반환한 프라미스를 우리가 감지하여서 에러처리를 해야하는 감지할 방법이 없게된다.

#### 절망의 구덩이

사라진/버려진 프라미스의 침묵속에 에러 또한 파묻히는걸 막으려만 반드시 프라미스 연쇄 끝부분에 `catch()`를 써야한다고 주장하는 개발자 들이 있다.

``` js
const p = Promise.resolve(21)

p.then(
	function fullFilled(msg) {
    console.log(msg.toLowerCase())
    // msg는 string이 아니므로 에러가 날 것이다.
  },
  function rejected(err) {
    console.log(err)
    // 실행안함.
  }
)
.catch(handleError)
```

버림처리기를 따로 `then()`에 넘기지 않아기때문에 에러는 다음 연쇄 프라미스로 그냥 전파된다. 따라서 결국 p로 유입된 에러 및 '이후' 귀결중 발생한 에러 모드 catch로 전달되게 되는 것이다.

하지만 `handleError`에서 또 에러가나면? 또 catch를 붙혀야하나? 끝나지 않는 지옥이다. 

#### 잡히지 않는 에러 처리

#### 성공의 구덩이

지금부터는 향후 프라미스가 변화할 방향을 제시하기 위한 이론적이 이야기들을 하고자 한다. 물론 ES6이후로 적용해 주면 좋겠지만 충분히 폴리필 해서 쓸 수 잇는 방법이다.

- 기본적으로 프라미스는 그다음 잡/이벤트 루프 틱 시점에 에러처리기 등록되어 있지 않을 경우 모든 버림을 알리도록 되어있다.
- 감지되기전 까지 버린 프라미스의 버림 상태를 계속해서 유지하려면 defer()를 호출해서 해당 프라미스에 관한 자동 에러 알림 기능을 끈다.

```js
const p = Promise.reject("허걱").defer()

foo(42)
.then(
	function fullfilled(){
    return p
  },
  function rejected(err) {
    // foo() 에러처리
  }
)
```

이런식으로 defer()를 달면 전역으로 에러가 났다는 것을 알리지 않는다. defer()는 계속 연쇄할 목적으로 같은 프라미스를 단순 반환한다.

반면 `then()`이 반환한 프라미스엔 `defer()`나 에러 처리기가 달ㅕ있지 않다. 프라미스가 버림되면 잡히지 않는 에러 형태로 개발자 콘솔창에 나타나게 될 것이다.

이러한 설계를 `성공의 구덩이`라고 한다. 대다수의 개발자들이 거의 모든 상황에서 기대하는바, 모든에러는 기본적으로 처리 또는 통지된다. 

처리기를 등록하거나 의도적으로 배제해야 하며 에러 처리를 `나중`에 할 테니 미루겠다는 의사를 밝혀야 한다. 특정 경우 부가적인 책임을 지겠다고 선택하는 것이다. 

이 접근 방식이 유일하게 위험할때는 `defer()`를 했으나 실제로 버림을 감지/처리 하지 못했을 때이다. 