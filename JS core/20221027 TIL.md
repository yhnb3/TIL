## 프라미스

일단 콜백의 제어의 역전부터 해결해보자. 

일단 프라미스는 프로그램의 진행을 다른파트에 넘겨주지 않고도 개발자가 언제 작업이 끝날지 알 수 있고 그 다음에 무슨 일을 해야할지 스스로 정할 수 있다.

#### 프라미스란?

개발자들은 본능적으로 코드를 먼저 보고 기술/패턴을 학습하는 경향이 있다. 잘 모르는 IT를 배울때 아주 당연한 수순처럼 여겨진다.

하지만 API만으로는 그 이면의 추상화까지 파악하기 어렵다. 프라미스가 꼭 그렇다. API를 빠르게 익혀 사용하는것과 API가 지향하는 바와 대상이 무엇인지 제대로 알고 쓰는 것이 얼마나 극적으로 달라질 수 있는지 뼈저리게 느끼게 해주는 도구 프라미스이다.

그래서 일단 프라미스의 개념에 대해 충분히 이야기하고 넘어가도록하겠다.

그럼 프라미스가 무엇인지에 대해 2가지 비유를 들고 시작하겠다.

#### 미래값

일단 내가 햄버거 집에 가서 치즈버거를 시킨다고 가정하자, 그럼 내가 치즈버거를 계산하고 주문번호가 적힌 영수증을 받을 것이다. 이 일련의 과정은 `지금`이루어지는 것이다. 그리고 내가 받은 주문번호는 치즈버거를 나에게 주겠다는 `프라미스(약속)`이다.

그리고 나는 치즈버거가 만들어지길 기다리면서 다양한 일들을 할 수 있다. 그리고 이미 나는 치즈버거가 내 손에 있는것 마냥 행동한다. 즉 주문번호가 적힌 영수증을 치즈버거로 생각하는 것이다. 이것을 우리는 `미래값`이라고 할 것이다.

그리고 치즈버거 나왔습니다 라는 얘기를 듣고 나는 영수증과 버거를 교환해 온다. 나의 `미래값`이 준비되어 갖고 있던 `값-프라미스`를 값 자체로 교환한 것이다.

하지만 항상 원하는 값을 받는건 아니다. 재료가 떨어져서 버거를 받지 못할 수도 있다. 우리는 `미래값`은 항상 성공과 실패라는 것을 명심해야한다.

**지금값과 나중값**

우리는 지금 값과 나중 값에 대해 어떻게 다루어야 할지 생각 해내는건 쉽지 않다.

그래서 `지금`과 `나중`을 일관적으로 다루기 위해서는 둘다 `나중`으로 만들어 모든 작업을 비동기화 하면 된다.

콜백식 접근법은 매우 복잡하고 수정할 것이 많게 된다. 그래서 어떤 값을 언제 손에 넣게 될지 미리 걱정하지 않아도 미랫값을 추론할 수 있다는 사실이 얼마나 유용한지 이제 좀 느낌이 올 것이다.

**프라미스 값**

```JS
function add(xPromise, yPromise) {
  return Promise.all([xPromise, yPromise])
  .then((values) => {
    return values[0] + values[1]
  })
}
// values[0] + values[1]을 가진 promise를 리턴한다.

add(fetchX(), fetchY())
.then((sum) => {
  consoel.log(sum)
})
```

두 계층의 프라미스가 있다.

뭐 이 코드에 대해서 짧게 설명하면

1. add 함수에서 Promise.all을 이용해서 비동기 요청을 병렬적으로 처리하고 모든 비동기 요청이 처리 됐을 경우를 상정하고 .then()으로 넘어가면된다.
2. .then()메서드는 또 다른 promise를 생성하고 그 안에 우리가 원하는 `미래 값인 values[0]와 values[1]`을 넣어서 리턴한다.
3. 그리고 add함수는 promise를 리턴 받기 때문에 .then()안에서 또 우리는 `미래값`을 가지고 놀 수 있게 되는 것이다. 예제에서는 로그를 찍었다.

그리고 치즈 버거 세트 처럼 우리는 `성공`과 `실패` 두가지 경우 모두를 고려해야한다.

프라미스 `then()`함수는 첫번째 인자로 이룸함수, 두번째 인자로 버림함수를 각각 넘겨 받는다. 

X나 Y의 조회에 실패하거나 연산에 실패 했을 경우 버림함수를 실행하고, 별탈 없이 성공했을 경우 이룸 함수를 실행한다.(번역해서 그런가 존나 어색하네 ㅋㅋ)

그리고 버림함수는 프라미스가 넘겨주는 버림값을 받는다.

> 프라미스는 시간 의존적인 상태를 외부로부터 캡슐화하기 때문에 프라미스 자체는 시간 독립적이다. 그래서 타이밍 또는 내부 결과값에 상관없이 예측 가능한 방향을 구성 할 수 있다.
>
> 또한, 프라미스가 귀결된 후에는 상태가 그대로 유지되므로(**불변한다.**) 몇 번이든 필요할 때마다 꺼내 쓸 수 있다.
>
> 불변성은 프라미스를 제대로 알려면 반드시 이해해야하는 중요한 개념이다. 

**- 프라미스는 미래값을 캡슐화하고 조합할 수 있게 해주는 손쉬운 반복장치이다. -**

#### 프라미스  이벤트

프라미스 각각은 미래값으로서 작동하지만 프라므스의 귀결은 비동기 작업의 여러 단계를 `흐름제어`하기 위한 체계라 볼 수 있다.

```js
function foo(x) {
  return new Promise((resolve, reject) => {
    // resolve와 reject중 하나 리턴
  })
}

var p = foo(42)
bar(p)
baz(p)

// 아마 bar와 baz의 내부는 다음과 같을 것이다.
function bar(fooPromise) {
  fooPromise.then(
  	function() {
      // foo()는 이제 bar()에서 작업한다.
    },
    function() {
      // foo()가 뭔가 잘못됐어.
    }
  )
}
// 혹은
function bar() {
  // foo를 여기서
}
function oopsBar() {
 	// foo가 잘못됐어
}

var p = foo(42)
p.then(bar, oopsBar)
p.thne(baz, oopsBaz)
```

전자는 `foo`프라미스가 reject, resolve 무엇을 가지고 있던 상관없이 실행한 후에 내부에서 처리하는 것이고

후자는 `foo`프라미스가 resolve를 가질때만 bar를 실행하고 그렇지 않으면 oopsBar를 실행한다.

어쨋거나 모두 `foo`프라미스를 제대로 핸들링한다.

그리고 p.then()과 같이 귀결된 프라미스는 영원히 똑같은 값을 가지므로 언제든지 다시 이용할 수 있다.

