## 제너레이터

자바스크립트는 일단 함수가 실행되기 시작하면 완료될 때까지 계속 실행되며 도중에 다른 코드가 끼어들어 실행되는 법이 없다고 얘기했었다.

그러나 ES6부터는 완전-실행 법칙을 따르지 않는 제너레이터러라는 전혀 새로운 종류의 함수가 등장했다.

그럼 끼어들기를 협동적 형태를 보여주는 예를 한번 보자.

```js
let x = 1
function *foo() {
  x++;
  yield // 멈춰!
  console.log("x : ", x)
}

function bar() {
  x++
}
```

```js
const it = foo()

it.next()
x; // 2
bar();
x; // 3
it.next()  // x: 3
```

이 일련의 코드를 찬찬히 살펴보면서 제너레이터가 어떻게 동작하는지 한번 알아보겠습니다.

1. `it = foo()`할당으로 제너레이터가 실행되는 것은 아닙니다. 제너레이터는 실행을 제어할 `이터레이터`만 마련합니다.
2. 첫번째 `it.next()`가 `*foo()`제너레이터를 시작하고 x++를 실행합니다.
3. 그럼 ` yield`에서 멈춥니다.
4. 그럼 현재 x 값은 2입니다.
5. `bar()`함수를 실행하면 x는 3이 됩니다.
6. 마지막 `it.next()`호출부에 의해 `*foo()` 제너레이터가 멈췄던 곳에서 재개 되어 console.log 실행 후 현재 x 값 3을 콘솔창에 표시합니다.

