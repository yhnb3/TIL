## ES6 함수의 추가기능

### 함수의 구분

es6이전에는 함수들이 모두 `callable`이면서 `contructor` 였습니다.

하지만 es6이후로 화살표 함수가 새로 나왔고 화살표 함수는 `non-contructor, non-prototype` 이지만 callable한 함수입니다. 굳이 생성자 일 필요가 없는 함수를 정의할 때 사용하면 됩니다. 그러니 우리는 함수형 프로그래밍을을 할때는 화살표 함수를 이용하는 것이 메모리적으로 이득일 것이라 생각합니다.

### 메서드

es6이전에는 딱히 메서드에 대해 명확한 정의가 존재하지 않았습니다.

es6이후로는 메서드는 메서드 축약형으로만 정의된 것을 메서드로 인정합니다.

```js
const obj = {
    x: 1,
    foo() { return this.x },
    bar: function() { return this.x },
}
```

`foo`는 메서드이고 `bar`는 메서드가 아닙니다.

메서드 또한 `non-prototype, non-constructor`이므로 아무래도 메서드로 정의 해서 사용하는 것이 좋겠습니다.

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObject]]`를 갖습니다. 이는 `super`로 참조할 수 있으며 메서드가 아닌 함수라면 사용할 수 없기에 이 또한 메서드를 명확히 정의해서 사용할 이유가 될 것입니다.

### 화살표 함수

```js
const func = () => { console.log("this is arrow function")}
```

이와 같이 표현식으로 함수를 정의하는 것이 화살표 함수입니다.

### 일반 함수와의 차이

- `non-contructor` 이다.
- 중복된 매개변수 이름을 선언할 수 없다.
- 함수 자체의 `this, arguments, super, new.target`바인딩을 갖지 않는다.

### this

`this`는 함수가 어떻게 호출되었는지에 따라서 동적으로 결정됩니다.

`화살표 함수는 함수 자체의 this를 가지지 않고 화살표 함수 내에서 this를 참조하면 사우이 스코프의 this를 그대로 참조합니다. 이를 lexical this 라고 합니다.` 이는 함수 선언 당시에 정해지는 lexical scope와 같이 화살표 함수의 this가 함수가 정의된 위치에 따라 정해지는 것을 의미합니다.

메서드를 화살표 함수로 정의하는 것은 피해야합니다. 그 이유인 즉슨 메서드의 `this`가 메서드를 가지는 객체가 아닌 상위 객체를 참조하기 때문입니다.

### Rest 파라미터

매개변수 앞에 `...`을 붙여서 배열 형태로 전달 받는것을 의미합니다.

```js
const func = (...args) => {
    console.log(args) // [1,2,3]
}
func(1,2,3)
```



