## 생성자 함수에 의한 객체 생성

> 생성자 함수란 `new` 연산자와 함께 호출하여 객체를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 `instance`라고 한다.

### 객체 리터럴에 의한 객체 생성 방식의 문제점

객체 리터럴은 간단하지만 하나의 객체만을 생성할 수 있고, 똑같은 프로퍼티를 가진 객체를 여러 개를 생성해야하는 경우에 어려움을 가진다.

### 생성자 함수에 의한 객체 생성 방식의 장점

생성자 함수를 템플릿처럼 활용하여 동일한 객체를 여러개 생산학가 쉽다.

### 생성자 함수의 인스턴스 생성 과정

1. 인스턴스 생성과 `this`바인딩

   암묵적으로 빈 객체가 생성되고, 이 빈객체가 바로 생성자 함수가 만든 인스턴스이다. 

   그리고 이 빈객체는 `this`에 바인딩 된다. 생성자 함수 내부의 `this`가 생성자 함수가 생성할 인스턴스를 가르키는 이유가 바로 이 때문이다.

2. 인스턴스 초기화

   생성자 함수에 있는 코드가 한 줄씩 실행되면서 `this`에 바인딩 된 객체를 형성한다.

3. 인스턴스 반환

   `this`를 리턴한다.

### 내부 메서드 [[Call]]과 [[Construct]]

함수는 객체이지만 일반 객체와는 다르다. **일반객체는 호출할 수 없지만 함수는 호출할 수 있다** 따라서 함수 객체는 일반 객체가 가지고 있는 내부 슬로소가 내부 메서드는 물론, 함수로서 동작하기 위해 함수 객체만을 위한 [[Environment]], [[FormalParameters]] 등의 내부 슬롯과 [[Call]], [[Contruct]] 같은 내부 메서드를 추가로 가지고 있다.

함수는 일반 함수로서 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고 `new` 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Contruct]]가 호출된다.

내부 메서드 [[Call]]을 가지는 객체를 callable하다고 표현하며, [[Construct]]를 갖는 함수 객체를 contructor, 가지지 않는 함수를 non-contructor라고 부른다.

- contructor : 함수 선언문, 표현식, 클래스
- non-contructor: 메서드(메서드의 축약표현만 인정), 화살표 함수

```javascript
const a = {
    x() {}   // 메서드의 축약표현
}
```

### new 연산자

#### new.target

`new` 연산자와 함께 호출되었는지를 확인할 수 있는 프로퍼티이다. `new`연산자와 함께 호출되지 않으면 `undefined`로 나오게 되고 그럼 다시 `new`를 이용해서 리턴해주면 `new`없이 호출되는 것을 막을 수 있다.





