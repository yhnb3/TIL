# frontend

### 브라우저의 동작 원리

1. HTML 마크업을 처리하고 DOM트리를 빌드한다.
2. CSS 마크업을 처리하고 CSSOM트리를 빌드한다.
3. DOM 및 CSSOM을 결합하여 렌더링 트리를 형성
4. 렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다.
5. 개별 느드를 화면에 페인트한다.

### DOM(Document Object Model)

문서 객체 모델(DOM, Document Object Model)은 XML이나 HTML 문서에 접근하기 위한 일종의 인터페이스입니다.

이 객체 모델은 문서 내의 모든 요소를 정의하고, 각각의 요소에 접근하는 방법을 제공합니다.

### CORS

다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 `cross-origin HTTP`요청에 의해 요청된다. 하지만 대부분의 브라우저들은 보안 상의 이유로 스크립트에서 `cross-origin HTTP`요청을 제한한다. 이를 동일출처정책이라고 한다. 

이러한 문제를 해결하기위해서는 `proxy`를 두고 타 도메익간 통신을 했다. 하지만 모바일 운영체제의 등장으로는 힘들어지면며서 특정 HTTP 헤더를 추가함으로써 해결하였다.

### 모듈 번들러와 트랜스 파일러

- 모듈 번들러

  현대 프론트엔드 개발은 모듈 단위로 파일을 엮어서 개발하는 방식이다. 모듈 번들러는 이러한 모듈들을 한데 모아 하나의 자바스크립트 파일로 만드는 도구이다. js기반 언어 뿐만아니라 static 파일과 css 파일도 압축 및 최소화 해준다. webpack, parcel 등이 있다.

- 트랜스 파일러

  특정 언어로 개발된 언어를 비슷한 다른 언어로 변환 시키는 행위이다. es6기반의 js를 es5기반의 js로 변경한다던지 react의 jsx 파일을 js파일로 변환 시킨다던지. 브라우저가 특정 언어만을 읽을 수 있기때문에 변환이 필요하다. babel이 대표적이다.

### local storage vs session storage vs cookie

- 쿠키

  클라이언트나 서버에서 생성하고 서버와 통신을 위한 것.

- local storage

  클라이언트가 생성 지울때까지 계속 존재

- session storage

  클라이언트에서 생성 탭/ 윈도우 닫을 때까지 지속

### 시맨틱 마크업

시맨틱이란 의미론적인 이란 뜻을 가지며 마크업이란 HTML 태그로 문서를 작성하는 것을 말한다.

### AJAX

비동기적으로 js를 사용해서 데이터를 받아와 DOM을 갱신 및 조작하는 웹 개발 기법을 의미한다. 여기서 XML이 있는 이유는 옛날레 데이터 포맷으로 XML을 많이 사용했기 때문

### 이벤트 위임

- 이벤트 버블링

  하위 엘리먼트에 이벤트가 발생 할대 그 엘리먼트 부터 상위 엘리먼트까지 이벤트가 전달되는 방식

- 이벤트 캡쳐링

  하위 엘리먼드에서 이벤트가 발생 할때 상위 엘리먼트부터 하위 엘리먼트로 이벤트가 전달되는 방식

> 하위 엘리먼트들이 여러개 있을때, 하위 엘리먼트들에 각 각 이벤트 핸들러를 달지 않고 상위 엘리먼트에 이벤트핸들러를 달아 하위 엘리먼트를 제어하는 방식이다.
>
> - 동적으로 엘리먼트를 추가할때마다 핸들러를 고려할 필요가 없다.
> - 코드가 깔끔해지고
> - 메모리에 있게되는 이벤트 핸들러가 적어지기 대문에 퍼포먼스 측면에서 이점이 있다.

### 실행 컨텍스트

> 코드의 실행환경에 대한 여러가지 정보를 담고있는 개념, 자바스크립트 엔진에 의해 만들어지고 사용되는 코드 정보를 담은 객체의 집합.

- lexical environment
- variable environment
- this 바인딩

### 스코프

> 자바스크립트 엔진이 참조의 대상이 되는 식별자를 검색할 대 사용하는 규칙의 집합이다.

- 렉시컬 스코프

  코드를 짤때, 변수 및 함수/블록 스코프를 어디에 작성하였는가에 따라 정해지는 스코프를 렉시컬 스코프라 한다.

- 스코프 체인.

  현재 스코프에서 식별자를 검색할때 상위 스코프를 연쇄적으로 찾아나가는 방식이다.

  lexical evironment 에서 식별자를 찾고 식별자가 없으면 outer 참조 값으로 상위 스코프에서 식별자를 검색 outer 참조 값이 `null`일때까지 반복

### 프로토 타입

- [[prototype]] : 자신의 프로토 타입 객체를 참조하는 속성
- .prototype :  `new`연산자로 자신을 생성자 함수로 사용한경우, 그걸로 만들어진 새로운 객체의 `[[prototype]]`이 참조하는 값이다.

즉 `func`함수로 `new`연산자로 `a `라는 객체를 만들었다고 했을때.

- a 라는 객체의 [[prototype]]의 참조 값은 `func.prototype`이다. 
- `func.prototype` 내에는 constuctor와 [[prototype]]이 있는데 [[prototype]]은 object.prototype을 참조 값으로 가진다.

#### 프로토 타입 체인

객체에 프로퍼티를 참조 할때 찾고자하는 프로퍼티가 객체에 존재하는지 확인후 존재하지 않는다면 [[prototype]]을 타고 올라가서 해당 프로퍼티를 찾는다.

할당도 마찬가지이다.

### === vs ==

==는 타입 변환 후에 비교

===는 타입 변환 없이 비교

### new의 동작방식

- 빈 객체를 생성
- [[prototype]] 속성을 func.prototype 속성으로 지정
- 객체를 생성하고 이 객체를 `this`로 지정
- 생성자 함수를 호출하고 해당 함수의 `this`로 위에서 지정한 객체를 사용.
- 해당 객체를 리턴

