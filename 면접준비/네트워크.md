# 네트워크

### HTTP get과 post

get

url상에 ? 에 데이터를 붙여서 request를 보내게된다. 하지만 이러한 방법은 데이터를 필수적으로 노출 시켜야 하기 대문에 보안이 필요한 데이터에는 적절치 않다.

post

`http request message`의 body부분에 데이터가 담겨서 전송된다. 그래서 보안면에서 낫다.

그리고 get 방식은 캐싱가능하다는 점도 다르다고 할 수있다.

### HTTP와 HTTPS

HTTP의 문제점

- 도청이 가능하고
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 대문에 변조가 가능하다,.

보완 방법

1. 통신 자체를 암호화 `SSL` or `TLS`라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화 할 수 있다. `SSL`을 조합한 HTTP를 HTTPS라 한다.
2. 콘텐츠를 암호화 말 그대로 HTTP 를 사용해서 운반하는 내용인 HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다. 

### 웹 통신의 큰 흐름

#### in browser

1.  url에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 그 의미를 조사.
2. 조사괸 의미에 따라 HTTP request 메시지를 만든다.
3. 만들어진 메시지를 웹 서버로 전송 한다.

> 이 때 만들어진 메시지 전송은 브라우저가 직접하는 것이 아니라 OS를 통해서 한다. 단 OS에서 송신할 때는 도메인 명이 아니라 ip 주소로 받을 상대를 지정해야 하므로 DNS서버를 통해 ip 주소를 알아내야한다.

### 3-way handshake

1. clinent-> server
   - 클라이언트가 서버로 syn 패킷 전송
   - 클라이언트는 syn_sent 상태
2. server -> client
   - 서버는 클라이언트에게 요청을 수락했으며 요청 프로세스인 크랑이언트도 포트를 열어달라는 메시지 전송
   - 즉, ack와 syn 패킷 전송
   - 서버는 syn_received 상태
3. client -> server
   - 클라이언트가 서버에게 ack보내고 연결 완료
   - 전송 가능

### 4-way handshake

1. client -> server
   - 클라이언트가 서버에게 연결을 끊겠다는 FIN 전송
2. server -> client
   - 서버가 일단 확인 메시지를 클라이언트에게 전송(ACK) 그리고 통신이 끝날때 까지 대기
3. server -> client
   - 통신이 끝나면 클라이언트에게 FIN 플래그 전송
4. client -> server
   - 클라이언트는 확인했다는 메시지 전송
   - 서버열결 닫힘.
