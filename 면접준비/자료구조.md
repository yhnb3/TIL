## 자료구조

1. 리스트와 연결리스트

   리스트 - 인덱스를 통해서 원소에 `O(1)`로 접근할 수 있다. 하지만 삭제 및 삽입은 `O(N)`의 시간 복잡도를 가진다.

   연결리스트 - 특정 원소에 접근하는데 `O(N)`의 시간 복잡도를 가지지만 삭제 및 삽입은 `O(1)`의 시간복잡도를 가진다. 트리를 구현할때 의미있는 자료구조이다.

2. 스택과 큐

   스택 -> LIFO 나중에 들어간 원소가 먼저 나온다. 

   큐 -> FIFO 먼저들어간 원소가 먼저 나온다. 우선순위큐등에 이용할 수 있다.

3. 트리

   비선형 자료구조이며 계층적 관계이다.

   노드 : 트리를 구성하고 있는 각각의 요소를 의미

   간선: 트리를 구성하기 위해 노드와 노드를 잇는 선을 의미

   루트노드: 최상단 노드

   단말노드: 하위노드가 없는 노드

   #### 이진트리

   자식을 두명 이하로 가지는 트리를 이진 트리라고 한다. 그리고 루트노드를 기준으로 모든 서브트리들이 이진트리를 만족해야한다.

   포화이진트리 - 모든레벨이 꽉찬 이진트리

   완전이진트리 - 아래 오른쪽부터 가장 루트노드까지 꽉찬 트리

   정 이진트리 - 모든 서브트리의 하위 노드가 0개 또는 2개인 트리

   #### BST 이진 탐색 트리

   효율적인 탐색을 위해 고안된 트리이며 왼쪽 자식은 자신보다 작은 값을 가지고 오른쪽 자식은 자신보다 큰 값을 가지는 트리이다.

   - 규칙1 : 이진탐색트리 노에 저장된 키는 유일하다.
   - 규칙2: 부모의 키가 왼쪽 자식보다 크다
   - 규칙3: 부모의 키가 오른쪽 자식보다 작다.
   - 규칙4: 오른쪽 서브트리 왼쪽 서브트리 모두 이진탐색 트리이디ㅏ.

   이진 탐색 트리의 탐색 연산은 O(logn)이다. 이것은 n개의 원소를 가진 배열을 이진 탐색 트리로 만들면 logN의 높이를 가진 트리가 나오기 때문이다.

4. 해쉬 테이블

   `hash`는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 같는다. 특정한 값을 찾는데 고유의 `index`로 접근하게 되므로 평균적으로`O(1)`의 시간 복잡도를 가진다. 하지만 이 인덱스로 저장되는 `key`값이 불규칙하다는 것이다.

   그래서 특별한 알고리즘을 통해 저장할 데이터와 관련된 고유한 숫자를 만들어 낸뒤 인덱스로 사용한다.

   #### 해쉬 펑션

   좋은 해쉬 평션은 키의 일부분 만을 이용해 인덱스를 만드는 것이 아니라 키 전체를 이용해서 인덱스를 만든다. 

   무조건적이로 collision 없이 1:1로 대응되게 만드는 것은 불가능 하기도 하고 그렇게 하면 array와 다를바 없다. 그래서 최소한의 collision을 만들되 collision에 어떻게 대응할 것인가가 중요하다. 

   #### resolve conflict

   1. 개방주소법.

      해쉬 충돌이 발생하면 다른 해시 버킷에 해당 자료를 삽입하는 방식이다.

      1. 선형으로 비어있는 버킷을 찾는다.
      2. 2차 함수를 이용해 비어있는 버킷을 찾는다.
      3. 하나의 해쉬함수가 충동하면 또 다른 2차 해쉬함수를 이용해 새로운 주소를 할당한다.

   2. 분리 연결법

      각 각의 버킷을 연결리스트로 만들어 주소가 겹칠 경우 연결리스트에 삽입한다.

5. 그래프

   정점과 간선의 집합인 그래프이다.

   정점과 정점 사이에 방향이 존재하면 directed graph

   존재하지 않는다면 undirected graph이다.

   그래프를 구현하는 대중적인 2가지 방법

   1. 인접행렬 
   2. 인접리스트

   #### 그래프 탐색

   1. 깊이우선탐색 DFS

      그래프 상에 임의의 한 점으로 부터 연결되어 있는 한 정점으로 나아가는 방법을 우선으로 탐색한다. 더 이상 나아갈 정점이 없을 때까지 탐색해나가는 것이다. 그러면 한 단계 전의 정점으로 돌아가 연결할 수 있는 정점이 있는지 파악하고 탐색한다. 

   2. 너비우선탐색 BFS

      그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아가나다. 

   #### MST

   `spanning tree`중 간선의 합이 최소인것을 말하며 `spanning tree`는 사이클이 없는 트리를 의미한다.

   1. kruskal algorithm

      edge들 중에 가장 작은 edge를 연결한 후 edge들과 연결할 수 있는 edge들 중 가장 작고 사이클이 되지 않는 간선을 연결한다.

      사이클이 되지 않게끔 하려면 연결된 모든 정점들이 하나의 정점을 가르키게끔 하고 그 정점을 가르키지 않는 정점끼리의 간선만을 추가하면 된다.

   2. prim algorithm

      연결할 수 있는 모든 edge들 중에 가장 작은 edge들을 골라서 연결한다. (사이클이 안되게끔) 