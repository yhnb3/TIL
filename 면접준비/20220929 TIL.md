## 데이터 베이스

### 데이터 베이스를 사용하는 이유

데이터의 종속성, 중복성, 무결성을 해결하기 위해

1. 데이터의 독립성

   - 물리적 독립성 : 데이터 베이스 사이즈를 늘리거나 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하여도 관련된 응용 프로그램을 수정할 필요가 없다.
   - 논리적 독립성 : 데이터 베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.

2. 데이터의 무결성

   여러 경로를 통해 잘못 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.

3. 데이터의 보안성

   인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함 으로써 모든 데이터에 보안을 구현할 수 있다.

4. 데이터의 일관성

   연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경 했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.

5. 데이터 중복 최소화

   데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

### 데이터 베이스의 성능

데이터베이스의 성능 이슈는 디스크 I/O를 어떻게 줄이느냐 이다. 

>디스크 I/O
>
>디스크 드라이브의 플래터를 돌려서 읽어야할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 

얼마나 디스크 헤더가 움직이지 않고 많은 데이터를 읽을 수 있냐에 다라 결정된다.

그래서 순차I/O가 랜덤 I/O보다 빠를 수 밖에 없다. 하지만 현실에서는 대부분의 I/O 작업이 랜던 I/O이다. 이러한 생각에서 부터 시작되는 데이터 베이스의 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.

### Index

말 그대로 색인이다. 책에서 어떤 내용이 있는지 알려주는 지표와 같은것이다.

DBMS도 데이터 베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장되 ㄴ주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다.

DBMS의 인덱스 항상 정렬된 상태를 유지하기 대문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가허거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다. 결론적으로 인덱스는 데이터 저장 성능을 희생하고 읽기 속도를 높이는 기능이다. SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이고 전부 인덱스로 생성하면 오히려 역효과가 날 수 있다.

### 정규화

갱신 이상을 방지하기 위해서

갱신이상의 종류

- 삽입이상: 원하는 자료가 삽입된다던지. 삽입하는데 자료가 부족해 삽입되지 않는 문제점
- 삭제 이상: 하나의 자료만 삭제하고 싶지만 그 자료과 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점
- 수정이상: 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해기거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점

그래서 **정규화**란 관계형 데이터 베이스에서 중복을 최소화 하기 위해 데이터를 구조화하는 작업이다. 불만족스러운 나쁜 릴에이션의 애트리뷰트들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업을 말한다. 정규화 과정을 거치게 되면 정규형을 만족하게된다.

#### 제 1 정규형

애트리뷰트의 도메인이 오직 `원자값`만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야한다. 즉, 복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등 비원자 적인 애트리뷰트들을 허용하지 않는 릴레이션의 형태를 말한다.

**좋아하는 게임 테이블**

| 이름(key) | 전화번호    | 좋아하는 게임 |
| --------- | ----------- | ------------- |
| john      | 010-123-123 | 롤            |
| steve     | 010-234-234 | 롤            |
| gary      | 010-345-241 | 스타          |
| john      | 010-123-123 | 스타          |
| john      | 010-123-123 | 발로란트      |
| steve     | 010-234-234 | 발로란트      |

이름과 전화번호가 중복해서 계속 등장한다. 아래와 같이 제 1 정규화를 할 수 있습니다.

**전화번호 테이블**

| 이름(key) | 전화번호    |
| --------- | ----------- |
| john      | 010-123-123 |
| steve     | 010-234-234 |
| gary      | 010-345-241 |

**좋아하는 게임**

| 이름(key) | 좋아하는 게임 |
| --------- | ------------- |
| john      | 롤            |
| john      | 발로란트      |
| john      | 스타          |
| steve     | 롤            |
| steve     | 발로란트      |
| gary      | 스타          |

#### 제 2 정규화

key가 아닌 칼럼들은 모두 key에 종속되어야 한다.

**수강내역 테이블**

| 학번 | 수강 과목    | 교실번호 |
| ---- | ------------ | -------- |
| 12   | 네트워크     | 401      |
| 13   | 데이터베이스 | 404      |
| 4    | 운영체제     | 305      |

다음을 보면 **교실번호** 칼럼은 학번에 종속되는 값이 아니라 수강 과목에 종속되는 값입니다. **제 2 정규화**를 해주면

| 학번 | 수강 과목    |
| ---- | ------------ |
| 12   | 네트워크     |
| 13   | 데이터베이스 |
| 4    | 운영체제     |

| 수강 과목    | 교실번호 |
| ------------ | -------- |
| 네트워크     | 401      |
| 데이터베이스 | 404      |
| 운영체제     | 305      |

#### 제 3 정규화

이형적 함수 종속 제거

제 2 정규형을 만족하고 테이블 내의 모든 속성이 키에만 의존하며 다른 후보키에 의존하지 않는다.

제 2 정규형을 만족하는 테이블 하나를 보겠습니다.

| 학번 | 이름  | 대학     | 전공         |
| ---- | ----- | -------- | ------------ |
| 101  | john  | 이과대학 | 통계학과     |
| 102  | steve | 공과대학 | 컴퓨터공학과 |
| 103  | gary  | 이과대학 | 수학과       |

전공이라는 칼럼을 잘 보면 전공은 대학에 종속된 개념이다. 통계학과이면 이과대학일수 밖에 없다. 그래서 제 3 정규화를 통해 테이블을 나누어야한다.

| 학번 | 이름  | 대학     |
| ---- | ----- | -------- |
| 101  | john  | 이과대학 |
| 102  | steve | 공과대학 |
| 103  | gary  | 이과대학 |

| 대학     | 전공         |
| -------- | ------------ |
| 이과대학 | 통계학과     |
| 공과대학 | 컴퓨터공학과 |
| 이과대학 | 수학과       |

다음과 같이 정규화를 해줄 수 있다.

#### 정규화의 장점은?

1. 데이터 베이스 변경시 이상 현상이 생기는 것을 방지할 수 있다.
2. 데이터 베이스 구조 확장시 일부만 변경해도 된다.
3.  사용자에게 데이터 모델을 더욱 의미있게 제공 

#### 단점은

릴레이션을 잘게 분해하다 보니 릴레이션 간의 join을 많이 할 수 밖에 없고 릴레이션간 join을 많이 해야하는 질의문은 속도가 필히 느려질 수 밖에 없다.

#### 이를 해결할 수 있는 방법은?

비정규화

정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법중 하나이다. 

테이블 끼리의 경로가 너무 멀어 조인으로 인해 성능 저하가 예상되거나 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다.

#### 반 정규화의 대상

1. 자주 사용되는 테이블에 액세스하는 프로세스의 수가 많고 항상 일정범위만을 조회하는 경우
2. 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우
3. 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우

데이터의 무결성을 해치지 않도록 유의 해야한다.

### 트랜잭션

트랜잭션이란 데이터의 `완전성`을 보장해주는 것이다. 데이터를 처리할때 완벽하게 처리하지 못한경우는 아무 처리 하지 않는 상태로 복구해 놓는 것을 의미한다. 사용자의 입장에서는 작업의 논리적 단위로 이해할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.

#### Lock

잠금은 동시성을 제어하기 위한 장치이다. 여러 커넥션에서 하나의 자원을 동시에 요청할때 한 번에 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. 

#### 트랜잭션의 특징

`원자성`: 트랜잭션의 중간에 문제가 발생하면 어떠한 작업도 수행되어서는 안되며 문제가 발생하지 않으면 반드시 수행해야한다.

`일관성` : 트랜잭션이 완료된 다음상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야한다.

`고립성`: 각 각의 트랜잭션은 독립적으로 수행되어야한다.

`지속성`: 트랜잭션이 종료된 후 영구적으로 데이터에 작업의 결과가 저장되어야 한다.

### 교착상태

두 개이상의 트랜잭션이 특정 자원의 잠긍을 획득한채 다른 트랙잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태를 `교착상태`라고 한다.

`transaction1`이 `resourece1`의 잠금을 들고 있고 `resourece2`의 잠금이 해제되는 것을 기다리고 있고

`transaction2`이 `resourece2`의 잠금을 들고 있고 `resourece1`의 잠금이 해제되는 것을 기다리고 있는 상태를 의미한다.

### No SQL

관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는데 특화 되어있으며 스키마 없이 사용가능 하거나 느슨한 스키마를 제공하는 저장소를 말한다.

> 스키마란?
>
> 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.
>
> 데이터 베이스를 구성하는 entity, attribute, relationship 및 데이터 조작 시 데이터 값들이 갖는 제약 조건등에 관해 전반적으로 정의한다.
>
> 사용자의 관점에 따라 외부와 내부 그리고 개념 스키마로 구분된다.
>
> #### 특징
>
> 데이터 사전에 저장되며, 다른 이름으로는 메타데이터 라고 한다.
>
> 현실 세계의 특정한 부부의 표현으로서 특정 데이터 모델을 이용해서 만들어 진다.
>
> 시간에 따라 불변인 특성을 갖는다.
>
> 데이터의 구조적인 특성을 의미하며 인스턴스에 의해 규정된다.

#### CAP 이론

1. 일관성

   다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터 임을 보증하는 것을 의미한다. 관계형 데이터 베이스는 기본으로 제공하는 기능이지만 NoSQL을 사용한다면 데이터의 일관성이 느슨하게 처리되어 동일한 데이터가 나타나지 않을 수 있다.

   각 NoSQL들은 분산 노드 간의 데이터 동기화를 위해 2가지 방법을 사용한다.

   1. 데이터 저장결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 동기식 방법이 있다, 느린 응답시간을 보이지만 데이터 정합성을 보장한다.
   2. 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화하는 비동기식 방법이 있다.

2. 가용성

    모든 클라이언트의 일기 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증하는 것이며 내고장성이라고도 한다. 내 고장성을 가진 NoSQL은 클러스터 내에서 몇 개의 노드가 망가지더라도 정상적인 서비스가 가능하다.

3. 네트워크 분할 허용성

   분할 허용성이란 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 네트워크 데이터 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야함을 의미한다.

### 여러 저장방식

1. key-value 방식

2. document Model 방식

   키 - 값 모델을 개념적으로 확장한 구조로 하나의 키에 하나의 구조화된 문서를 저장하고 조회한다. 논리적인 데이터 저장과 조회 방법이 관계형 데이터 베이스와 유사하다. 키는 문서에 대한 ID로 표현된다. 또한 저장된 무서를 컬렉션으로 관리하여 문서 저장과 동시에 문서 ID에 대한 인덱스를 생성한다.

3. column Model

   하나의 키에 여러개의 칼럼 이름과 칼럼 값의 쌍ㅇ으로 이루어진 데이터를 저장하고 조회한다. 모든 칼럼은 항상 타임 스탬프 값과 함께 저장된다.

   대부분의 칼럼 모델 NoSQL은 쓰기와 읽기 중에 쓰기에 더 특화 되어있다. 데이터ㅡㄹ 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답 속도를 제공한다. 