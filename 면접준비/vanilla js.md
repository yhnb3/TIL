# vanilla js

> 싱글 스레드 언어이다.

#### 비동기 처리

> 비동기 처리라 함은 자바스크립트가 싱글 스레드라는 특성때문에 동시에 여러 작업을 할 수 없기 때문에 동시는 아니지만 효율적인 실행을 위한것이다.
>
> 어떤 함수를 실행하는데에 걸리는 시간 동안 기다리지 않고 다른 함수들을 실행하는 것이다.

#### 이벤트 루프

자바스크립트에서 비동기 처리를 하게끔 해주는 도구가 이벤트 루프이다.

이벤트 루프는 task queue에 쌓여있는 작업들을 call stack으로 옮겨주는 작업을 해준다.

1. 자바스크립트 파일 읽기
2. 동기 처리가 가능한 함수들은 call stack에 쌓이고
3. 비동기 처리를 해야하는 함수들은 web api에 쌓인다.
4. web api는 비동기 처리를 한후에 콜백함수들을 task queue로 보낸다.
5. call stack에 있는 함수들이 모두 처리되면 task queue에 쌓인 함수들이 call stack으로 옮겨진다.
6. call stack과 web api 그리고 task queue가 모두 비면 끝이난다.

### 호이스팅

`var`변수가 어디서 선언되어지는지와 상관없이 가장 처음에 선언되는 것이다. 하지만 할당은 기존에 할당되어지는 위치에서 이루어진다.

함수 호이스팅

함수 선언문 -> 함수자체가 끌어올려진다.

함수 리터럴 -> 할당이 되지 않기 때문에 type error를 일으킨다.

#### 과연 const와 let은 호이스팅 되지 않는 것일까?

`const`와 `let`이 `var`과 다른점은 Temporal Dead Zone의 제약을 받는 것이다. 

변수를 초기화 하기전에 액세스하려고 하면 `ReferenceError`가 발생한다.

### 클로저

> 두 개의 함수로 만들어진 환경으로 이루어진 특별한 기술적 기반 혹은 컨셉?

#### 클로저 생성되는 조건

1. 내부 함수가 익명함수로 되어 외부 함수의 반환값으로 사용
2. 내부함수는 외부함수의 실행환경에서 실행된다.
3. 내부 함수에서 사용되는 변수 x는 외부 함수의 변수 스코프에 있다.

이는 클로저의 내부함수는 외부함수와 스코프 체인으로 연결되어 있어서 외부 함수의 스코프에 변수에 접근이 가능하기 때문이다. 그래서 외부 함수가 종료 되더라도 내부함수는 외부함수의 변수에 접근할 수 있게되는 구조를 클러저라 한다.

전역변수의 사용억제할 수 있고, 정보를 은닉할 수 있다.

### this

일반적이 상황에서 `this`는 항상 `글로벌`를 가르킨다.

하지만 몇몇 상황에서는 다르다

#### 상황 1. 객체의 메서드를 호출할때.

어떠한 객체에 메서드가 선언 되어 있고 그 객체의 메서드를 호출 하면 그 메서드 내에서의 `this`는 객체를 가르킨다.

#### 상황 2. 생성자 함수를 통해 객체를 생성할때

생성자 함수를 통해 객체를 생성하면 그 객체 내에서의 `this`는 그 객체를 가르킨다.

>  new 연산자를 통해 함수를 생성자로 호출하게 되면
>
> 1. 함수의 프로토타입을 상속하는 객체를 만들어 `this`에 바인딩하고
> 2. 생성자 함수 본문을 실행합니다. `this`에 새로운 프로퍼티를 추가해 `this`를 수정한다.
> 3. `this`를 반환한다.

#### 상황 3. apply, call, bind를 통한 호출

bind - 객체에 `this`를 바인딩 한 함수를 리턴한다.

apply - 객체에 `this`를 바인딩하여 실행한다. call과 의 차이점이라면 변수를 각각으로 넘겨야한다.

call - 객체에 `this`를 바인딩하여 실행한다. 변수를 배열의 형태로 전달해야한다.

#### 상황 4. arrow function

화살표 함수에서의 `this`는 항상 한 단계 상위 객체를 가르킨다. 

ex) 객체 내에 함수가 콜백 함수를 arrow function으로 구현하면 그 함수 내에 `this`는 그 객체를 가르킨다.

### Promise

비동기 처리할때 콜백이 중첩되는 경우가 발생하였고 이를 해결하기 위해 등장한 것이 promise 패턴이다. 비동기 작업을 순차적으로 진행하거나 병렬로 진행하는 등 컨트롤이 보다 수월해 진다.

### Async/Await

비동기 처리를 마치 동기 처리하는 것 처럼 코딩 할 수 있다.