# 알고리즘

### sort algorithm

- 버블정렬 

  인접한 두 데이터를 비교하가면서 정렬 

  시간복잡도 : O(N^2)

- 선택정렬

  계속 해서 바꾸는 것이 아니라 비교하고 있는 값의 index를 저장후 최종적으로 한번만 바꿔준다.

  시간복잡도 : O(N^2)

- 삽입정렬

  i 번째 인덱스가 정렬할 순서라고하면 0~i-1번째 원소들이 정렬되어 있다고 가정하면 i번째 원소보다 큰 원소를 만나면 한칸민다. 그리고 작은 원소를 만나면 그 원소 다음 자리에 i번째 원소 값을 넣는다.

  시간복잡도 : O(N^2)

- 병합정렬

  divide & conquer을 이용한 정렬이다.

  우선 최소 단위로 나누어서 그 최소 단위를 가진 배열을 합치면서 전체 배열을 정렬하게끔 하는 것이다.

  2개의 배열을 하나의 배열로 합치는 방법은 각 배열에 시작 인덱스에 포인터를 두고 더 작은 값을 가지는 인덱스는 그 값을 새로운 배열에 넣고 인덱스를 오른쪽으로 옮긴다. 이것을 반복한다.

  시간복잡도: O(nlogn)

- 힙 정렬

  heap이라는 자료구로를 이용한다.

  힙에 데이터를 저장하는 시간 복잡도는  O(log n)이고 데이터를 n개 저장해야하기 때문에

  시간복잡도: O(nlogn)

- 퀵 정렬

  분할 정복을 이용해서 구현

  피벗 을 기준으로 피벗보다 작은값과 큰값들을이 오게끔 한다. 그리고 왼쪽 부분과 오른쪽 부분을 똑같이 분할하여 계속한다.

  low index는 피벗을 제외한 가장 작은 index부터 시작

  high index는 피벗을 제외하 가장 큰 index부터 시작

  low index는 pivot보다 큰 값일때가지 증가

  high index는 pivot보다 작은 값일때 까지 

  두 조건이 모두 만족하면 high, row index의 값을 스왑

  low와 hight가 교차하면 그만한다. high의 값과 pivot의 값을 스왑하면 pivot값을 기준으로 왼쪽은 pivot보다 작은 값들 그리고 오른쪽은 pivot보다 큰 값들이 모이게 된다.

  이 것을 길이가 2 or 3인 배열까지 분할하여 정복하면 정렬이 완료된다.  